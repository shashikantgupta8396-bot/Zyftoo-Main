{
    "sourceFile": "backend/src/admin/services/CategoryService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1753440030082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753441696968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,12 +6,12 @@\n  * \r\n  * @module CategoryService\r\n  */\r\n \r\n-const Category = require('../../../models/Category');\r\n-const Media = require('../../../models/Media');\r\n-const { getImageUrl, deleteImageFile } = require('../../../utils/fileUpload');\r\n-const { constants } = require('../../config');\r\n+const Category = require('../../models/Category');\r\n+const Media = require('../../models/Media');\r\n+const { getImageUrl, deleteImageFile } = require('../../utils/fileUpload');\r\n+const { constants } = require('../config');\r\n \r\n class CategoryService {\r\n   /**\r\n    * Create a new category\r\n"
                }
            ],
            "date": 1753440030082,
            "name": "Commit-0",
            "content": "/**\r\n * Category Service\r\n * \r\n * Business logic for category operations\r\n * Handles data processing, validation, and database operations\r\n * \r\n * @module CategoryService\r\n */\r\n\r\nconst Category = require('../../../models/Category');\r\nconst Media = require('../../../models/Media');\r\nconst { getImageUrl, deleteImageFile } = require('../../../utils/fileUpload');\r\nconst { constants } = require('../../config');\r\n\r\nclass CategoryService {\r\n  /**\r\n   * Create a new category\r\n   * @param {Object} categoryData - Category data\r\n   * @returns {Promise<Object>} Created category\r\n   */\r\n  async createCategory(categoryData) {\r\n    console.log('üîß [CategoryService] Creating category:', categoryData.name);\r\n    \r\n    // Validate business rules\r\n    if (categoryData.parent) {\r\n      await this.validateSubcategoryLimits(categoryData.parent);\r\n    } else {\r\n      await this.validateMainCategoryLimits();\r\n    }\r\n\r\n    const category = new Category(categoryData);\r\n    await category.save();\r\n    \r\n    // Transform for frontend compatibility\r\n    return this.transformCategory(category);\r\n  }\r\n\r\n  /**\r\n   * Get categories with filtering and pagination\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Categories with pagination info\r\n   */\r\n  async getCategories(options = {}) {\r\n    console.log('üîß [CategoryService] Fetching categories with options:', options);\r\n    \r\n    const { page, limit, parent, status, search } = options;\r\n    \r\n    // Build query\r\n    const query = {};\r\n    \r\n    if (parent !== undefined) {\r\n      query.parent = parent === 'null' || parent === '' ? null : parent;\r\n    }\r\n    \r\n    if (status !== undefined) {\r\n      query.status = status === 'true';\r\n    }\r\n    \r\n    if (search) {\r\n      query.$or = [\r\n        { name: { $regex: search, $options: 'i' } },\r\n        { description: { $regex: search, $options: 'i' } }\r\n      ];\r\n    }\r\n\r\n    // Execute query with pagination\r\n    const skip = (page - 1) * limit;\r\n    const [categories, total] = await Promise.all([\r\n      Category.find(query)\r\n        .populate('parent', 'name _id')\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit),\r\n      Category.countDocuments(query)\r\n    ]);\r\n\r\n    // Transform categories\r\n    const transformedCategories = categories.map(cat => this.transformCategory(cat));\r\n\r\n    return {\r\n      data: transformedCategories,\r\n      pagination: {\r\n        currentPage: page,\r\n        totalPages: Math.ceil(total / limit),\r\n        totalItems: total,\r\n        itemsPerPage: limit,\r\n        hasNextPage: page < Math.ceil(total / limit),\r\n        hasPrevPage: page > 1\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get category by ID\r\n   * @param {string} categoryId - Category ID\r\n   * @returns {Promise<Object|null>} Category or null\r\n   */\r\n  async getCategoryById(categoryId) {\r\n    console.log('üîß [CategoryService] Fetching category by ID:', categoryId);\r\n    \r\n    const category = await Category.findById(categoryId).populate('parent', 'name _id');\r\n    return category ? this.transformCategory(category) : null;\r\n  }\r\n\r\n  /**\r\n   * Update category\r\n   * @param {string} categoryId - Category ID\r\n   * @param {Object} updateData - Update data\r\n   * @returns {Promise<Object>} Updated category\r\n   */\r\n  async updateCategory(categoryId, updateData) {\r\n    console.log('üîß [CategoryService] Updating category:', categoryId);\r\n    \r\n    // Validate business rules if parent is being changed\r\n    if (updateData.parent) {\r\n      await this.validateSubcategoryLimits(updateData.parent);\r\n    }\r\n\r\n    const category = await Category.findByIdAndUpdate(\r\n      categoryId, \r\n      updateData, \r\n      { new: true, runValidators: true }\r\n    ).populate('parent', 'name _id');\r\n    \r\n    return this.transformCategory(category);\r\n  }\r\n\r\n  /**\r\n   * Delete category\r\n   * @param {string} categoryId - Category ID\r\n   * @returns {Promise<boolean>} Success status\r\n   */\r\n  async deleteCategory(categoryId) {\r\n    console.log('üîß [CategoryService] Deleting category:', categoryId);\r\n    \r\n    const category = await Category.findById(categoryId);\r\n    \r\n    // Delete image if exists\r\n    if (category.image?.path) {\r\n      await this.deleteImage(category.image.path);\r\n    }\r\n\r\n    await Category.findByIdAndDelete(categoryId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if category has subcategories\r\n   * @param {string} categoryId - Category ID\r\n   * @returns {Promise<boolean>} Has subcategories\r\n   */\r\n  async hasSubcategories(categoryId) {\r\n    const count = await Category.countDocuments({ parent: categoryId });\r\n    return count > 0;\r\n  }\r\n\r\n  /**\r\n   * Build category hierarchy\r\n   * @returns {Promise<Array>} Category tree\r\n   */\r\n  async buildCategoryHierarchy() {\r\n    console.log('üîß [CategoryService] Building category hierarchy...');\r\n    \r\n    const categories = await Category.find({ status: true })\r\n      .populate('parent', 'name _id')\r\n      .sort({ name: 1 });\r\n\r\n    // Build tree structure\r\n    const categoryMap = new Map();\r\n    const rootCategories = [];\r\n\r\n    // First pass: create map\r\n    categories.forEach(cat => {\r\n      const transformed = this.transformCategory(cat);\r\n      transformed.children = [];\r\n      categoryMap.set(cat._id.toString(), transformed);\r\n    });\r\n\r\n    // Second pass: build hierarchy\r\n    categories.forEach(cat => {\r\n      const transformed = categoryMap.get(cat._id.toString());\r\n      \r\n      if (cat.parent) {\r\n        const parent = categoryMap.get(cat.parent._id.toString());\r\n        if (parent) {\r\n          parent.children.push(transformed);\r\n        }\r\n      } else {\r\n        rootCategories.push(transformed);\r\n      }\r\n    });\r\n\r\n    return rootCategories;\r\n  }\r\n\r\n  /**\r\n   * Process image upload\r\n   * @param {Object} file - Uploaded file\r\n   * @param {string} categoryName - Category name for alt text\r\n   * @returns {Promise<Object>} Image data\r\n   */\r\n  async processImageUpload(file, categoryName) {\r\n    console.log('üîß [CategoryService] Processing image upload...');\r\n    \r\n    const imageUrl = getImageUrl(file.path, { protocol: 'http', get: () => 'localhost:5000' });\r\n    \r\n    // Create media record\r\n    const media = new Media({\r\n      filename: file.filename,\r\n      originalName: file.originalname,\r\n      mimetype: file.mimetype,\r\n      size: file.size,\r\n      path: file.path,\r\n      url: imageUrl,\r\n      category: 'category',\r\n      alt: `${categoryName} image`\r\n    });\r\n    \r\n    await media.save();\r\n    \r\n    return {\r\n      url: imageUrl,\r\n      path: file.path,\r\n      filename: file.filename,\r\n      mediaId: media._id\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delete image file\r\n   * @param {string} imagePath - Image path\r\n   * @returns {Promise<boolean>} Success status\r\n   */\r\n  async deleteImage(imagePath) {\r\n    console.log('üîß [CategoryService] Deleting image:', imagePath);\r\n    \r\n    try {\r\n      deleteImageFile(imagePath);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('‚ùå Error deleting image:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform bulk operations\r\n   * @param {string} operation - Operation type\r\n   * @param {Array} categoryIds - Category IDs\r\n   * @param {Object} data - Operation data\r\n   * @returns {Promise<Object>} Operation result\r\n   */\r\n  async performBulkOperation(operation, categoryIds, data = {}) {\r\n    console.log(`üîß [CategoryService] Performing bulk ${operation} on ${categoryIds.length} categories`);\r\n    \r\n    let result = { success: 0, failed: 0, errors: [] };\r\n\r\n    switch (operation) {\r\n      case 'delete':\r\n        for (const id of categoryIds) {\r\n          try {\r\n            const hasSubcats = await this.hasSubcategories(id);\r\n            if (!hasSubcats) {\r\n              await this.deleteCategory(id);\r\n              result.success++;\r\n            } else {\r\n              result.failed++;\r\n              result.errors.push(`Category ${id} has subcategories`);\r\n            }\r\n          } catch (error) {\r\n            result.failed++;\r\n            result.errors.push(`Failed to delete ${id}: ${error.message}`);\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'updateStatus':\r\n        try {\r\n          await Category.updateMany(\r\n            { _id: { $in: categoryIds } },\r\n            { status: data.status }\r\n          );\r\n          result.success = categoryIds.length;\r\n        } catch (error) {\r\n          result.failed = categoryIds.length;\r\n          result.errors.push(error.message);\r\n        }\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unsupported bulk operation: ${operation}`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Validate main category limits\r\n   */\r\n  async validateMainCategoryLimits() {\r\n    const mainCategoryCount = await Category.countDocuments({ parent: null });\r\n    \r\n    if (mainCategoryCount >= constants.BUSINESS_RULES.CATEGORY.MAX_MAIN_CATEGORIES) {\r\n      throw new Error(`Maximum ${constants.BUSINESS_RULES.CATEGORY.MAX_MAIN_CATEGORIES} main categories allowed`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate subcategory limits\r\n   * @param {string} parentId - Parent category ID\r\n   */\r\n  async validateSubcategoryLimits(parentId) {\r\n    const subcategoryCount = await Category.countDocuments({ parent: parentId });\r\n    \r\n    if (subcategoryCount >= constants.BUSINESS_RULES.CATEGORY.MAX_SUBCATEGORIES_PER_CATEGORY) {\r\n      throw new Error(`Maximum ${constants.BUSINESS_RULES.CATEGORY.MAX_SUBCATEGORIES_PER_CATEGORY} subcategories per category allowed`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform category for frontend compatibility\r\n   * @param {Object} category - Category document\r\n   * @returns {Object} Transformed category\r\n   */\r\n  transformCategory(category) {\r\n    return {\r\n      ...category.toObject(),\r\n      id: category._id.toString() // Add id field for frontend compatibility\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = new CategoryService();\r\n"
        }
    ]
}