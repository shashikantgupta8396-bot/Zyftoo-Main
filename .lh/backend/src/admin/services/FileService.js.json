{
    "sourceFile": "backend/src/admin/services/FileService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753440030084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753440030084,
            "name": "Commit-0",
            "content": "/**\r\n * File Service\r\n * \r\n * Service for handling file operations, uploads, and static file generation\r\n */\r\n\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst { ApiError } = require('../utils');\r\n\r\nclass FileService {\r\n  /**\r\n   * Write data to a file\r\n   */\r\n  static async writeFile(filePath, data, options = {}) {\r\n    try {\r\n      // Ensure directory exists\r\n      const dir = path.dirname(filePath);\r\n      await fs.mkdir(dir, { recursive: true });\r\n\r\n      // Write file\r\n      await fs.writeFile(filePath, data, { encoding: 'utf8', ...options });\r\n      \r\n      console.log(`‚úÖ File written successfully: ${filePath}`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`‚ùå Error writing file ${filePath}:`, error);\r\n      throw new ApiError(500, `Failed to write file: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read data from a file\r\n   */\r\n  static async readFile(filePath, options = {}) {\r\n    try {\r\n      const data = await fs.readFile(filePath, { encoding: 'utf8', ...options });\r\n      return data;\r\n    } catch (error) {\r\n      if (error.code === 'ENOENT') {\r\n        throw new ApiError(404, `File not found: ${filePath}`);\r\n      }\r\n      throw new ApiError(500, `Failed to read file: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if file exists\r\n   */\r\n  static async fileExists(filePath) {\r\n    try {\r\n      await fs.access(filePath);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a file\r\n   */\r\n  static async deleteFile(filePath) {\r\n    try {\r\n      await fs.unlink(filePath);\r\n      console.log(`üóëÔ∏è File deleted: ${filePath}`);\r\n      return true;\r\n    } catch (error) {\r\n      if (error.code === 'ENOENT') {\r\n        return true; // File already doesn't exist\r\n      }\r\n      throw new ApiError(500, `Failed to delete file: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate static data file for frontend\r\n   */\r\n  static async generateStaticDataFile(data, outputPath, options = {}) {\r\n    const {\r\n      varName = 'data',\r\n      includeMetadata = true,\r\n      prettify = true\r\n    } = options;\r\n\r\n    let content = '';\r\n\r\n    if (includeMetadata) {\r\n      content += `// Auto-generated file - DO NOT EDIT MANUALLY\\n`;\r\n      content += `// Generated at: ${new Date().toISOString()}\\n`;\r\n      content += `// Source: Admin Configuration\\n\\n`;\r\n    }\r\n\r\n    const jsonData = prettify ? JSON.stringify(data, null, 2) : JSON.stringify(data);\r\n    content += `export const ${varName} = ${jsonData};\\n\\n`;\r\n    content += `export default ${varName};\\n`;\r\n\r\n    await this.writeFile(outputPath, content);\r\n    return content;\r\n  }\r\n\r\n  /**\r\n   * Generate backup of existing file\r\n   */\r\n  static async createBackup(filePath) {\r\n    const exists = await this.fileExists(filePath);\r\n    if (!exists) return null;\r\n\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n    const backupPath = `${filePath}.backup.${timestamp}`;\r\n    \r\n    try {\r\n      const content = await this.readFile(filePath);\r\n      await this.writeFile(backupPath, content);\r\n      console.log(`üìã Backup created: ${backupPath}`);\r\n      return backupPath;\r\n    } catch (error) {\r\n      console.error(`‚ùå Failed to create backup:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean old backup files\r\n   */\r\n  static async cleanOldBackups(directory, pattern, maxAge = 7 * 24 * 60 * 60 * 1000) {\r\n    try {\r\n      const files = await fs.readdir(directory);\r\n      const backupFiles = files.filter(file => file.includes(pattern) && file.includes('.backup.'));\r\n      \r\n      const now = Date.now();\r\n      let cleanedCount = 0;\r\n\r\n      for (const file of backupFiles) {\r\n        const filePath = path.join(directory, file);\r\n        const stats = await fs.stat(filePath);\r\n        \r\n        if (now - stats.mtime.getTime() > maxAge) {\r\n          await this.deleteFile(filePath);\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      if (cleanedCount > 0) {\r\n        console.log(`üßπ Cleaned ${cleanedCount} old backup files`);\r\n      }\r\n\r\n      return cleanedCount;\r\n    } catch (error) {\r\n      console.error(`‚ùå Error cleaning backups:`, error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = FileService;\r\n"
        }
    ]
}