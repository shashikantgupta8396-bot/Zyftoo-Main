{
    "sourceFile": "backend/src/controllers/orderController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753722023565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753722023565,
            "name": "Commit-0",
            "content": "const Order = require('../models/Order');\r\nconst User = require('../models/User'); \r\nconst sendEmail = require('../utils/sendEmail'); \r\nconst Product = require('../models/Product');\r\nconst Cart = require('../models/Cart');\r\nconst Address = require('../models/Address'); \r\n\r\n// Helper function to determine user type\r\nconst getUserType = (user) => {\r\n  return user.accountType === 'corporate' || user.userType === 'Corporate' ? 'corporate' : 'individual';\r\n};\r\n\r\n// Helper function to get effective price for a product\r\nconst getEffectivePrice = (product, user, quantity = 1) => {\r\n  const userType = getUserType(user);\r\n  \r\n  // If corporate user and product has corporate pricing\r\n  if (userType === 'corporate' && product.corporatePricing?.enabled && product.corporatePricing.priceTiers?.length > 0) {\r\n    // Find the appropriate tier based on quantity\r\n    const applicableTier = product.corporatePricing.priceTiers\r\n      .filter(tier => quantity >= tier.minQuantity && (!tier.maxQuantity || quantity <= tier.maxQuantity))\r\n      .sort((a, b) => b.minQuantity - a.minQuantity)[0]; // Get the highest minimum quantity tier that applies\r\n    \r\n    if (applicableTier) {\r\n      return applicableTier.pricePerUnit;\r\n    }\r\n  }\r\n  \r\n  // Fallback to regular pricing\r\n  return product.finalPrice || product.retailPrice?.sellingPrice || product.sale_price || product.price;\r\n};\r\n\r\n// Helper function to validate and update stock\r\nconst validateAndUpdateStock = async (product, requestedQuantity) => {\r\n  // Check if product is published\r\n  if (!product.status) {\r\n    return { valid: false, message: `Product ${product.name} is not available` };\r\n  }\r\n  \r\n  // Handle different stock statuses\r\n  switch (product.stock_status) {\r\n    case 'out_of_stock':\r\n      return { valid: false, message: `Product ${product.name} is out of stock` };\r\n    \r\n    case 'in_stock':\r\n      if (product.quantity < requestedQuantity) {\r\n        return { valid: false, message: `Insufficient stock for ${product.name}. Available: ${product.quantity}, Requested: ${requestedQuantity}` };\r\n      }\r\n      // Reduce stock for in_stock items\r\n      product.quantity -= requestedQuantity;\r\n      break;\r\n    \r\n    case 'pre_order':\r\n    case 'back_order':\r\n      // For pre-order and back-order, we don't reduce physical stock\r\n      // but we can track orders\r\n      break;\r\n    \r\n    default:\r\n      return { valid: false, message: `Invalid stock status for ${product.name}` };\r\n  }\r\n  \r\n  // Update sales count and analytics\r\n  product.sales_count = (product.sales_count || 0) + requestedQuantity;\r\n  \r\n  // Update analytics if they exist\r\n  if (product.analytics) {\r\n    // You could add order analytics here if needed\r\n  }\r\n  \r\n  await product.save();\r\n  return { valid: true };\r\n}; \r\n\r\n\r\nconst placeOrder = async (req, res) => {\r\n  try {\r\n    const { items, shippingAddress, paymentMethod, totalAmount } = req.body;\r\n\r\n    if (!items || items.length === 0) {\r\n      return res.status(400).json({ message: 'No items in order.' });\r\n    }\r\n\r\n    const userType = getUserType(req.user);\r\n    let calculatedTotal = 0;\r\n    const processedItems = [];\r\n\r\n    // ✅ Step 1: Validate products, check stock, and calculate total\r\n    for (const item of items) {\r\n      const product = await Product.findById(item.product);\r\n      if (!product) {\r\n        return res.status(404).json({ message: `Product not found: ${item.product}` });\r\n      }\r\n\r\n      // Check if user can access this product (corporate-only restriction)\r\n      if (product.is_corporate_only && userType !== 'corporate') {\r\n        return res.status(403).json({ \r\n          message: `Product ${product.name} is only available to corporate customers` \r\n        });\r\n      }\r\n\r\n      // Check corporate minimum order quantity\r\n      if (userType === 'corporate' && product.corporatePricing?.enabled) {\r\n        const minOrderQty = product.corporatePricing.minimumOrderQuantity || 1;\r\n        if (item.quantity < minOrderQty) {\r\n          return res.status(400).json({\r\n            message: `Minimum order quantity for ${product.name} is ${minOrderQty} for corporate customers`,\r\n            minimumQuantity: minOrderQty,\r\n            requestedQuantity: item.quantity\r\n          });\r\n        }\r\n      }\r\n\r\n      // Calculate effective price for this user and quantity\r\n      const effectivePrice = getEffectivePrice(product, req.user, item.quantity);\r\n      const itemTotal = effectivePrice * item.quantity;\r\n      calculatedTotal += itemTotal;\r\n\r\n      // Prepare processed item for order\r\n      processedItems.push({\r\n        product: item.product,\r\n        quantity: item.quantity,\r\n        priceAtTime: effectivePrice,\r\n        itemTotal: itemTotal,\r\n        productName: product.name,\r\n        productSku: product.sku,\r\n        stockStatus: product.stock_status,\r\n        corporatePricing: userType === 'corporate' && product.corporatePricing?.enabled ? {\r\n          tierApplied: product.corporatePricing.priceTiers?.find(tier => \r\n            item.quantity >= tier.minQuantity && (!tier.maxQuantity || item.quantity <= tier.maxQuantity)\r\n          )\r\n        } : null\r\n      });\r\n    }\r\n\r\n    // Validate total amount (allow small rounding differences)\r\n    if (Math.abs(calculatedTotal - totalAmount) > 0.1) {\r\n      return res.status(400).json({ \r\n        message: 'Total amount mismatch', \r\n        calculated: calculatedTotal, \r\n        provided: totalAmount \r\n      });\r\n    }\r\n\r\n    // ✅ Step 2: Update stock for all products (do this after all validations pass)\r\n    for (let i = 0; i < items.length; i++) {\r\n      const item = items[i];\r\n      const product = await Product.findById(item.product);\r\n      \r\n      const stockUpdate = await validateAndUpdateStock(product, item.quantity);\r\n      if (!stockUpdate.valid) {\r\n        // If stock update fails, we need to rollback any previous stock changes\r\n        // For now, we'll return an error. In production, you might want to implement proper rollback\r\n        return res.status(400).json({ message: stockUpdate.message });\r\n      }\r\n    }\r\n\r\n    // ✅ Step 3: Create enhanced order\r\n    const newOrder = new Order({\r\n      user: req.user._id,\r\n      items: processedItems,\r\n      shippingAddress,\r\n      paymentMethod,\r\n      totalAmount: calculatedTotal,\r\n      userType,\r\n      orderMetadata: {\r\n        hasCorporatePricing: processedItems.some(item => item.corporatePricing),\r\n        stockStatuses: processedItems.map(item => ({\r\n          product: item.product,\r\n          stockStatus: item.stockStatus\r\n        }))\r\n      }\r\n    });\r\n\r\n    const savedOrder = await newOrder.save();\r\n\r\n    // ✅ Step 4: Clear user's cart after successful order\r\n    try {\r\n      await Cart.findOneAndUpdate(\r\n        { user: req.user._id },\r\n        { $set: { items: [] } }\r\n      );\r\n    } catch (cartError) {\r\n      console.warn('Failed to clear cart after order:', cartError);\r\n      // Don't fail the order if cart clearing fails\r\n    }\r\n\r\n    // ✅ Step 5: Populate order for response\r\n    await savedOrder.populate([\r\n      { path: 'user', select: 'name email accountType userType' },\r\n      { path: 'items.product', select: 'name images sku' }\r\n    ]);\r\n\r\n    res.status(201).json({\r\n      message: 'Order placed successfully',\r\n      order: savedOrder,\r\n      calculatedTotal,\r\n      userType\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error placing order:', error);\r\n    res.status(500).json({ \r\n      message: 'Failed to place order',\r\n      error: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'\r\n    });\r\n  }\r\n};\r\n\r\n\r\nconst getMyOrders = async (req, res) => {\r\n  try {\r\n    const orders = await Order.find({ user: req.user._id })\r\n      .populate([\r\n        { \r\n          path: 'items.product', \r\n          select: 'name images price retailPrice corporatePricing is_corporate_only stock_status rating numReviews' \r\n        }\r\n      ])\r\n      .sort({ createdAt: -1 });\r\n\r\n    // Enhanced orders with additional info for frontend\r\n    const enhancedOrders = orders.map(order => {\r\n      const orderObj = order.toObject();\r\n      \r\n      // Add summary information\r\n      orderObj.summary = {\r\n        totalItems: orderObj.items.reduce((sum, item) => sum + item.quantity, 0),\r\n        userType: orderObj.userType || getUserType(req.user),\r\n        hasCorporatePricing: orderObj.items.some(item => item.corporatePricing),\r\n        hasPreOrders: orderObj.items.some(item => item.stockStatus === 'pre_order'),\r\n        hasBackOrders: orderObj.items.some(item => item.stockStatus === 'back_order')\r\n      };\r\n\r\n      return orderObj;\r\n    });\r\n\r\n    res.status(200).json({\r\n      orders: enhancedOrders,\r\n      totalOrders: orders.length\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching user orders:', error);\r\n    res.status(500).json({ message: 'Failed to fetch orders' });\r\n  }\r\n};\r\n\r\n\r\nconst getAllOrders = async (req, res) => {\r\n  try {\r\n    const { page = 1, limit = 10, status, userType } = req.query;\r\n    \r\n    // Build filter\r\n    const filter = {};\r\n    if (status) filter.orderStatus = status;\r\n    if (userType) filter.userType = userType;\r\n\r\n    const orders = await Order.find(filter)\r\n      .populate([\r\n        { path: 'user', select: 'name email accountType userType' },\r\n        { \r\n          path: 'items.product', \r\n          select: 'name images price retailPrice corporatePricing is_corporate_only stock_status sku' \r\n        }\r\n      ])\r\n      .sort({ createdAt: -1 })\r\n      .limit(limit * 1)\r\n      .skip((page - 1) * limit);\r\n\r\n    const totalOrders = await Order.countDocuments(filter);\r\n\r\n    // Enhanced orders with analytics\r\n    const enhancedOrders = orders.map(order => {\r\n      const orderObj = order.toObject();\r\n      \r\n      // Add analytics and summary\r\n      orderObj.analytics = {\r\n        totalItems: orderObj.items.reduce((sum, item) => sum + item.quantity, 0),\r\n        averageItemPrice: orderObj.totalAmount / orderObj.items.reduce((sum, item) => sum + item.quantity, 0),\r\n        hasCorporatePricing: orderObj.items.some(item => item.corporatePricing),\r\n        corporateDiscount: orderObj.items\r\n          .filter(item => item.corporatePricing?.tierApplied)\r\n          .reduce((sum, item) => sum + (item.corporatePricing.tierApplied.discount || 0), 0),\r\n        productTypes: {\r\n          corporateOnly: orderObj.items.filter(item => item.product?.is_corporate_only).length,\r\n          preOrders: orderObj.items.filter(item => item.stockStatus === 'pre_order').length,\r\n          backOrders: orderObj.items.filter(item => item.stockStatus === 'back_order').length\r\n        }\r\n      };\r\n\r\n      return orderObj;\r\n    });\r\n\r\n    res.status(200).json({\r\n      orders: enhancedOrders,\r\n      pagination: {\r\n        currentPage: parseInt(page),\r\n        totalPages: Math.ceil(totalOrders / limit),\r\n        totalOrders,\r\n        hasNext: page * limit < totalOrders,\r\n        hasPrev: page > 1\r\n      },\r\n      summary: {\r\n        totalRevenue: enhancedOrders.reduce((sum, order) => sum + order.totalAmount, 0),\r\n        corporateOrders: enhancedOrders.filter(order => order.userType === 'corporate').length,\r\n        individualOrders: enhancedOrders.filter(order => order.userType === 'individual').length\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching all orders:', error);\r\n    res.status(500).json({ message: 'Failed to fetch all orders' });\r\n  }\r\n};\r\n\r\nconst updateOrderStatus = async (req, res) => {\r\n  const { orderId } = req.params;\r\n  const { newStatus } = req.body;\r\n\r\n  const allowedStatuses = ['Processing', 'Shipped', 'Delivered', 'Cancelled'];\r\n  if (!allowedStatuses.includes(newStatus)) {\r\n    return res.status(400).json({ message: 'Invalid status value' });\r\n  }\r\n\r\n  try {\r\n    const order = await Order.findById(orderId).populate('user', 'name email');\r\n\r\n    if (!order) {\r\n      return res.status(404).json({ message: 'Order not found' });\r\n    }\r\n\r\n    order.orderStatus = newStatus;\r\n    await order.save();\r\n    order.statusHistory.push({ status: newStatus });\r\n\r\n\r\n    const subject = `Your Order #${order._id} is now ${newStatus}`;\r\n        const html = `\r\n        <p>Hi ${order.user.name},</p>\r\n        <p>Your order status has been updated to <strong>${newStatus}</strong>.</p>\r\n        <p>Thank you for shopping with us!</p>\r\n        `;\r\n\r\n        await sendEmail({\r\n        to: order.user.email,\r\n        subject,\r\n        html\r\n        });\r\n\r\n        res.status(200).json({ message: 'Order status updated & email sent', order });\r\n    } catch (error) {\r\n        console.error('Error updating order status:', error);\r\n        res.status(500).json({ message: 'Failed to update status' });\r\n    }\r\n    };\r\n\r\nconst cancelOrder = async (req, res) => {\r\n  const { orderId } = req.params;\r\n\r\n  try {\r\n    const order = await Order.findById(orderId).populate('user', 'email name');\r\n\r\n    if (!order) {\r\n      return res.status(404).json({ message: 'Order not found' });\r\n    }\r\n\r\n    if (order.user._id.toString() !== req.user._id.toString()) {\r\n      return res.status(403).json({ message: 'Not authorized to cancel this order' });\r\n    }\r\n\r\n    if (order.orderStatus !== 'Processing') {\r\n      return res.status(400).json({ message: 'Order cannot be cancelled at this stage' });\r\n    }\r\n    \r\n    // ✅ Restore stock\r\n    for (const item of order.items) {\r\n      const product = await Product.findById(item.product._id);\r\n      if (product) {\r\n        product.stock += item.quantity;\r\n        await product.save();\r\n      }\r\n    }\r\n\r\n    order.orderStatus = 'Cancelled';\r\n    order.isCancelled = true;\r\n    await order.save();\r\n\r\n    // ✅ Send cancellation email\r\n    const subject = `Order #${order._id} Cancelled`;\r\n    const html = `\r\n      <p>Hi ${order.user.name || 'Customer'},</p>\r\n      <p>Your order <strong>#${order._id}</strong> has been successfully <strong>cancelled</strong>.</p>\r\n      <p>If you have already made payment, please allow 5–7 business days for a refund.</p>\r\n      <p>Thank you for using Zyftoo!</p>\r\n    `;\r\n\r\n    if (order.user.email) {\r\n      await sendEmail({ to: order.user.email, subject, html });\r\n    } else {\r\n      console.warn(`⚠️ User ${order.user._id} has no email`);\r\n    }\r\n\r\n    res.status(200).json({ message: 'Order cancelled successfully & email sent', order });\r\n  } catch (error) {\r\n    console.error('Cancel Order Error:', error);\r\n    res.status(500).json({ message: 'Failed to cancel order' });\r\n  }\r\n};\r\n\r\n\r\nconst getSingleOrder = async (req, res) => {\r\n  const { orderId } = req.params;\r\n\r\n  try {\r\n    const order = await Order.findById(orderId)\r\n      .populate('user', 'name email')\r\n      .populate('items.product', 'name price brand images');\r\n\r\n    if (!order) {\r\n      return res.status(404).json({ message: 'Order not found' });\r\n    }\r\n\r\n    // ✅ Ensure the logged-in user owns the order OR is admin\r\n    if (\r\n      order.user._id.toString() !== req.user._id.toString() &&\r\n      req.user.role !== 'admin'\r\n    ) {\r\n      return res.status(403).json({ message: 'Not authorized to view this order' });\r\n    }\r\n\r\n    res.status(200).json(order);\r\n  } catch (error) {\r\n    console.error('Error fetching order:', error);\r\n    res.status(500).json({ message: 'Failed to fetch order' });\r\n  }\r\n};\r\n\r\nconst placeOrderFromCart = async (req, res) => {\r\n  const userId = req.user._id;\r\n  const { shippingAddress, paymentMethod, addressId } = req.body;\r\n\r\nlet finalAddress = shippingAddress;\r\n\r\nif (!finalAddress && addressId) {\r\n  const savedAddress = await Address.findOne({ _id: addressId, user: userId });\r\n  if (!savedAddress) {\r\n    return res.status(400).json({ message: 'Address not found or unauthorized' });\r\n  }\r\n  finalAddress = savedAddress.toObject();\r\n}\r\n\r\nif (!finalAddress) {\r\n  const defaultAddress = await Address.findOne({ user: userId, isDefault: true });\r\n  if (!defaultAddress) {\r\n    return res.status(400).json({ message: 'No shipping address provided and no default found' });\r\n  }\r\n  finalAddress = defaultAddress.toObject();\r\n}\r\n\r\n\r\n  try {\r\n    const cart = await Cart.findOne({ user: userId }).populate('items.product');\r\n    if (!cart || cart.items.length === 0) {\r\n      return res.status(400).json({ message: 'Cart is empty' });\r\n    }\r\n\r\n    let totalAmount = 0;\r\n    const orderItems = [];\r\n\r\n    // 1. Validate stock & prepare order items\r\n    for (const item of cart.items) {\r\n      const product = item.product;\r\n      if (!product || product.stock < item.quantity) {\r\n        return res.status(400).json({ message: `Insufficient stock for ${product?.name}` });\r\n      }\r\n\r\n      // Deduct stock\r\n      product.stock -= item.quantity;\r\n      await product.save();\r\n\r\n      totalAmount += product.price * item.quantity;\r\n      orderItems.push({\r\n        product: product._id,\r\n        quantity: item.quantity\r\n      });\r\n    }\r\n\r\n    // 2. Create order\r\n    const order = new Order({\r\n      user: userId,\r\n      items: orderItems,\r\n      shippingAddress,\r\n      paymentMethod,\r\n      totalAmount\r\n    });\r\n\r\n    await order.save();\r\n\r\n    // 3. Clear cart\r\n    cart.items = [];\r\n    await cart.save();\r\n\r\n    const user = await User.findById(userId);\r\n    const productListHTML = orderItems.map(item => {\r\n      const prod = cart.items.find(p => p.product._id.toString() === item.product.toString());\r\n      return `<li>${prod?.product.name} × ${item.quantity}</li>`;\r\n    }).join('');\r\n\r\n    const emailHTML = `\r\n      <p>Hi ${user.name},</p>\r\n      <p>Thank you for your order!</p>\r\n      <p><strong>Order ID:</strong> ${order._id}</p>\r\n      <p><strong>Total:</strong> ₹${order.totalAmount}</p>\r\n      <p><strong>Shipping Address:</strong></p>\r\n      <p>${shippingAddress.fullName}, ${shippingAddress.address}, ${shippingAddress.city}, ${shippingAddress.state}, ${shippingAddress.country} - ${shippingAddress.postalCode}</p>\r\n      <p><strong>Products:</strong></p>\r\n      <ul>${productListHTML}</ul>\r\n      <p>We'll notify you once it's shipped.</p>\r\n      <p>Thanks for shopping with <strong>Zyftoo</strong>!</p>\r\n    `;\r\n\r\n    await sendEmail({\r\n      to: user.email,\r\n      subject: `Order Confirmation - Zyftoo #${order._id}`,\r\n      html: emailHTML\r\n    });\r\n\r\n\r\n    res.status(201).json({\r\n      message: 'Order placed and confirmation email sent ✅',\r\n      order\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Order from cart error:', error);\r\n    res.status(500).json({ message: 'Failed to place order' });\r\n  }\r\n};\r\n\r\n\r\nmodule.exports={placeOrder, \r\n                getMyOrders, \r\n                getAllOrders, \r\n                updateOrderStatus, \r\n                cancelOrder, \r\n                getSingleOrder, \r\n                placeOrderFromCart\r\n                };\r\n"
        }
    ]
}