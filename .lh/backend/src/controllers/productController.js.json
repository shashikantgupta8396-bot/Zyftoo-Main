{
    "sourceFile": "backend/src/controllers/productController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1753640078106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753722023588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,20 @@\n       is_featured,\r\n       is_popular,\r\n       is_trending,\r\n       is_return,\r\n-      status\r\n+      status,\r\n+      // New fields from updated model\r\n+      variations,\r\n+      related_products,\r\n+      cross_sell_products,\r\n+      is_random_related_products,\r\n+      safe_checkout,\r\n+      secure_checkout,\r\n+      social_share,\r\n+      encourage_order,\r\n+      encourage_view,\r\n+      is_corporate_only\r\n     } = req.body;\r\n \r\n     // Required fields check\r\n     if (!name || !description || !price || !categories || !categories.length) {\r\n@@ -129,9 +140,22 @@\n       is_featured,\r\n       is_popular,\r\n       is_trending,\r\n       is_return,\r\n-      status\r\n+      status,\r\n+\r\n+      // New fields from updated model\r\n+      variations,\r\n+      related_products,\r\n+      cross_sell_products,\r\n+      is_random_related_products,\r\n+      safe_checkout,\r\n+      secure_checkout,\r\n+      social_share,\r\n+      encourage_order,\r\n+      encourage_view,\r\n+      is_corporate_only,\r\n+      createdBy: req.user?.id || req.adminUser?.id // Set admin who created the product\r\n     });\r\n \r\n     const savedProduct = await product.save();\r\n \r\n@@ -226,9 +250,20 @@\n     'is_featured',\r\n     'is_popular',\r\n     'is_trending',\r\n     'is_return',\r\n-    'status'\r\n+    'status',\r\n+    // New fields from updated model\r\n+    'variations',\r\n+    'related_products',\r\n+    'cross_sell_products',\r\n+    'is_random_related_products',\r\n+    'safe_checkout',\r\n+    'secure_checkout',\r\n+    'social_share',\r\n+    'encourage_order',\r\n+    'encourage_view',\r\n+    'is_corporate_only'\r\n   ];\r\n \r\n   fieldsToUpdate.forEach(field => {\r\n     if (req.body[field] !== undefined) {\r\n"
                },
                {
                    "date": 1753722806253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,109 +175,450 @@\n // @desc    Get all products\r\n // @route   GET /api/products\r\n // @access  Public\r\n const getAllProducts = asyncHandler(async (req, res) => {\r\n-  const products = await Product.find().populate({\r\n-    path: 'categories',\r\n-    populate: {\r\n-      path: 'parent',\r\n-      model: 'Category'\r\n+  try {\r\n+    const { \r\n+      page = 1, \r\n+      limit = 10, \r\n+      category, \r\n+      featured, \r\n+      popular, \r\n+      trending, \r\n+      status = true,\r\n+      userType,\r\n+      corporateOnly,\r\n+      minPrice,\r\n+      maxPrice,\r\n+      stockStatus,\r\n+      search\r\n+    } = req.query;\r\n+\r\n+    // Build filter object\r\n+    const filter = {};\r\n+    \r\n+    // Status filter (default to active products)\r\n+    filter.status = status === 'true';\r\n+    \r\n+    // Category filter\r\n+    if (category) {\r\n+      filter.categories = { $in: [category] };\r\n     }\r\n-  });\r\n-  res.status(200).json({ products });\r\n+    \r\n+    // Flag filters\r\n+    if (featured === 'true') filter.is_featured = true;\r\n+    if (popular === 'true') filter.is_popular = true;\r\n+    if (trending === 'true') filter.is_trending = true;\r\n+    \r\n+    // Corporate filter\r\n+    if (corporateOnly === 'true') {\r\n+      filter.is_corporate_only = true;\r\n+    } else if (userType !== 'corporate') {\r\n+      // Hide corporate-only products from individual users\r\n+      filter.is_corporate_only = { $ne: true };\r\n+    }\r\n+    \r\n+    // Price range filter\r\n+    if (minPrice || maxPrice) {\r\n+      filter.price = {};\r\n+      if (minPrice) filter.price.$gte = parseFloat(minPrice);\r\n+      if (maxPrice) filter.price.$lte = parseFloat(maxPrice);\r\n+    }\r\n+    \r\n+    // Stock status filter\r\n+    if (stockStatus) {\r\n+      filter.stock_status = stockStatus;\r\n+    }\r\n+    \r\n+    // Search filter\r\n+    if (search) {\r\n+      filter.$or = [\r\n+        { name: { $regex: search, $options: 'i' } },\r\n+        { description: { $regex: search, $options: 'i' } },\r\n+        { short_description: { $regex: search, $options: 'i' } },\r\n+        { sku: { $regex: search, $options: 'i' } }\r\n+      ];\r\n+    }\r\n+\r\n+    // Calculate pagination\r\n+    const skip = (parseInt(page) - 1) * parseInt(limit);\r\n+    \r\n+    // Get products with pagination\r\n+    const products = await Product.find(filter)\r\n+      .populate([\r\n+        {\r\n+          path: 'categories',\r\n+          select: 'name slug parent',\r\n+          populate: {\r\n+            path: 'parent',\r\n+            model: 'Category',\r\n+            select: 'name slug'\r\n+          }\r\n+        },\r\n+        {\r\n+          path: 'related_products',\r\n+          select: 'name price images stock_status',\r\n+          match: { status: true }\r\n+        },\r\n+        {\r\n+          path: 'cross_sell_products',\r\n+          select: 'name price images stock_status',\r\n+          match: { status: true }\r\n+        }\r\n+      ])\r\n+      .sort({ createdAt: -1 })\r\n+      .skip(skip)\r\n+      .limit(parseInt(limit));\r\n+\r\n+    // Get total count for pagination\r\n+    const totalProducts = await Product.countDocuments(filter);\r\n+    \r\n+    // Add calculated fields for frontend\r\n+    const enhancedProducts = products.map(product => {\r\n+      const productObj = product.toObject();\r\n+      \r\n+      // Add pricing summary\r\n+      productObj.pricingSummary = {\r\n+        hasRetailPrice: !!(productObj.retailPrice?.sellingPrice),\r\n+        hasCorporatePrice: !!(productObj.corporatePricing?.enabled),\r\n+        lowestPrice: productObj.retailPrice?.sellingPrice || productObj.price,\r\n+        hasDiscount: (productObj.retailPrice?.discount > 0) || \r\n+                    (productObj.compare_price && productObj.compare_price > productObj.price)\r\n+      };\r\n+      \r\n+      // Add stock summary\r\n+      productObj.stockSummary = {\r\n+        isAvailable: productObj.stock_status === 'in_stock' && productObj.quantity > 0,\r\n+        isLowStock: productObj.quantity > 0 && productObj.quantity <= 5,\r\n+        allowsPreOrder: productObj.stock_status === 'pre_order',\r\n+        allowsBackOrder: productObj.stock_status === 'back_order'\r\n+      };\r\n+      \r\n+      return productObj;\r\n+    });\r\n+\r\n+    res.status(200).json({ \r\n+      products: enhancedProducts,\r\n+      pagination: {\r\n+        currentPage: parseInt(page),\r\n+        totalPages: Math.ceil(totalProducts / parseInt(limit)),\r\n+        totalProducts,\r\n+        productsPerPage: parseInt(limit),\r\n+        hasNext: skip + parseInt(limit) < totalProducts,\r\n+        hasPrev: parseInt(page) > 1\r\n+      },\r\n+      filters: {\r\n+        category,\r\n+        featured,\r\n+        popular,\r\n+        trending,\r\n+        corporateOnly,\r\n+        priceRange: { minPrice, maxPrice },\r\n+        stockStatus,\r\n+        search\r\n+      }\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error fetching products:', error);\r\n+    res.status(500).json({\r\n+      message: 'Internal server error while fetching products',\r\n+      error: error.message\r\n+    });\r\n+  }\r\n });\r\n \r\n // @desc    Get product by ID\r\n // @route   GET /api/products/:id\r\n // @access  Public\r\n const getProductById = asyncHandler(async (req, res) => {\r\n-  const product = await Product.findById(req.params.id).populate({\r\n-    path: 'categories',\r\n-    populate: {\r\n-      path: 'parent',\r\n-      model: 'Category'\r\n+  try {\r\n+    const { userType, userId } = req.query;\r\n+    \r\n+    const product = await Product.findById(req.params.id)\r\n+      .populate([\r\n+        {\r\n+          path: 'categories',\r\n+          select: 'name slug parent',\r\n+          populate: {\r\n+            path: 'parent',\r\n+            model: 'Category',\r\n+            select: 'name slug'\r\n+          }\r\n+        },\r\n+        {\r\n+          path: 'related_products',\r\n+          select: 'name price images stock_status retailPrice corporatePricing is_corporate_only',\r\n+          match: { status: true }\r\n+        },\r\n+        {\r\n+          path: 'cross_sell_products',\r\n+          select: 'name price images stock_status retailPrice corporatePricing is_corporate_only',\r\n+          match: { status: true }\r\n+        }\r\n+      ]);\r\n+\r\n+    if (!product) {\r\n+      return res.status(404).json({ message: 'Product not found' });\r\n     }\r\n-  });\r\n-  if (!product) {\r\n-    return res.status(404).json({ message: 'Product not found' });\r\n+\r\n+    // Check access permissions\r\n+    if (product.is_corporate_only && userType !== 'corporate') {\r\n+      return res.status(403).json({ \r\n+        message: 'This product is only available to corporate customers' \r\n+      });\r\n+    }\r\n+\r\n+    // Update analytics\r\n+    const updateData = {\r\n+      $inc: {\r\n+        'analytics.views.total': 1,\r\n+        'analytics.weeklyViews': 1,\r\n+        'analytics.monthlyViews': 1\r\n+      },\r\n+      'analytics.lastViewed': new Date()\r\n+    };\r\n+\r\n+    // Increment user-type specific views\r\n+    if (userType === 'corporate') {\r\n+      updateData.$inc['analytics.views.corporate'] = 1;\r\n+    } else if (userType === 'individual') {\r\n+      updateData.$inc['analytics.views.individual'] = 1;\r\n+    } else {\r\n+      updateData.$inc['analytics.views.anonymous'] = 1;\r\n+    }\r\n+\r\n+    // Add daily view tracking\r\n+    const today = new Date().toISOString().split('T')[0];\r\n+    updateData.$push = {\r\n+      'analytics.dailyViews': {\r\n+        $each: [{ date: today, count: 1 }],\r\n+        $slice: -30 // Keep last 30 days\r\n+      }\r\n+    };\r\n+\r\n+    // Update analytics in background (don't wait)\r\n+    Product.findByIdAndUpdate(req.params.id, updateData).exec();\r\n+\r\n+    // Get product object with calculated fields\r\n+    const productObj = product.toObject();\r\n+    \r\n+    // Add calculated pricing information\r\n+    if (userType === 'corporate' && productObj.corporatePricing?.enabled) {\r\n+      const { getProductPrice } = require('../utils/productPricing');\r\n+      productObj.calculatedPricing = {\r\n+        retail: getProductPrice(productObj, 'individual', 1),\r\n+        corporate: getProductPrice(productObj, 'corporate', 1),\r\n+        tiers: productObj.corporatePricing.priceTiers.map(tier => ({\r\n+          ...tier,\r\n+          calculatedPrice: getProductPrice(productObj, 'corporate', tier.minQuantity)\r\n+        }))\r\n+      };\r\n+    } else {\r\n+      productObj.calculatedPricing = {\r\n+        retail: getProductPrice(productObj, 'individual', 1)\r\n+      };\r\n+    }\r\n+\r\n+    // Add stock information\r\n+    productObj.stockInfo = {\r\n+      isAvailable: productObj.stock_status === 'in_stock' && productObj.quantity > 0,\r\n+      isLowStock: productObj.quantity > 0 && productObj.quantity <= 5,\r\n+      allowsPreOrder: productObj.stock_status === 'pre_order',\r\n+      allowsBackOrder: productObj.stock_status === 'back_order',\r\n+      estimatedRestockDate: productObj.available_from || null\r\n+    };\r\n+\r\n+    // Filter related products based on user access\r\n+    if (productObj.related_products) {\r\n+      productObj.related_products = productObj.related_products.filter(relatedProduct => \r\n+        !relatedProduct.is_corporate_only || userType === 'corporate'\r\n+      );\r\n+    }\r\n+\r\n+    if (productObj.cross_sell_products) {\r\n+      productObj.cross_sell_products = productObj.cross_sell_products.filter(crossSellProduct => \r\n+        !crossSellProduct.is_corporate_only || userType === 'corporate'\r\n+      );\r\n+    }\r\n+\r\n+    res.status(200).json({ \r\n+      product: productObj,\r\n+      viewTracked: true,\r\n+      userAccess: {\r\n+        canPurchase: !productObj.is_corporate_only || userType === 'corporate',\r\n+        canViewPrice: true,\r\n+        userType: userType || 'anonymous'\r\n+      }\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error fetching product:', error);\r\n+    res.status(500).json({\r\n+      message: 'Internal server error while fetching product',\r\n+      error: error.message\r\n+    });\r\n   }\r\n-  res.status(200).json({ product });\r\n });\r\n \r\n // @desc    Update a product\r\n // @route   PUT /api/products/:id\r\n // @access  Private (Admin only)\r\n const updateProduct = asyncHandler(async (req, res) => {\r\n-  const productId = req.params.id;\r\n-  const product = await Product.findById(productId);\r\n-  if (!product) {\r\n-    return res.status(404).json({ message: 'Product not found' });\r\n-  }\r\n+  try {\r\n+    const productId = req.params.id;\r\n+    const product = await Product.findById(productId);\r\n+    if (!product) {\r\n+      return res.status(404).json({ message: 'Product not found' });\r\n+    }\r\n \r\n-  // Only update fields present in the Product schema\r\n-  const fieldsToUpdate = [\r\n-    'name',\r\n-    'short_description',\r\n-    'description',\r\n-    'price',\r\n-    'compare_price',\r\n-    'cost_price',\r\n-    'sale_price',\r\n-    'discount',\r\n-    'retailPrice',           // New field\r\n-    'corporatePricing',      // New field\r\n-    'sku',\r\n-    'quantity',\r\n-    'stock_status',\r\n-    'type',\r\n-    'unit',\r\n-    'weight',\r\n-    'requires_shipping',\r\n-    'available_from',\r\n-    'available_to',\r\n-    'categories',\r\n-    'tags',\r\n-    'images',\r\n-    'product_thumbnail_id',\r\n-    'product_galleries_id',\r\n-    'size_chart_image_id',\r\n-    'meta_title',\r\n-    'meta_description',\r\n-    'product_meta_image_id',\r\n-    'is_free_shipping',\r\n-    'tax_id',\r\n-    'estimated_delivery_text',\r\n-    'return_policy_text',\r\n-    'is_featured',\r\n-    'is_popular',\r\n-    'is_trending',\r\n-    'is_return',\r\n-    'status',\r\n-    // New fields from updated model\r\n-    'variations',\r\n-    'related_products',\r\n-    'cross_sell_products',\r\n-    'is_random_related_products',\r\n-    'safe_checkout',\r\n-    'secure_checkout',\r\n-    'social_share',\r\n-    'encourage_order',\r\n-    'encourage_view',\r\n-    'is_corporate_only'\r\n-  ];\r\n+    const {\r\n+      name,\r\n+      short_description,\r\n+      description,\r\n+      price,\r\n+      compare_price,\r\n+      cost_price,\r\n+      sale_price,\r\n+      discount,\r\n+      retailPrice,\r\n+      corporatePricing,\r\n+      sku,\r\n+      quantity,\r\n+      stock_status,\r\n+      type,\r\n+      unit,\r\n+      weight,\r\n+      requires_shipping,\r\n+      available_from,\r\n+      available_to,\r\n+      categories,\r\n+      tags,\r\n+      images,\r\n+      product_thumbnail_id,\r\n+      product_galleries_id,\r\n+      size_chart_image_id,\r\n+      meta_title,\r\n+      meta_description,\r\n+      product_meta_image_id,\r\n+      is_free_shipping,\r\n+      tax_id,\r\n+      estimated_delivery_text,\r\n+      return_policy_text,\r\n+      is_featured,\r\n+      is_popular,\r\n+      is_trending,\r\n+      is_return,\r\n+      status,\r\n+      variations,\r\n+      related_products,\r\n+      cross_sell_products,\r\n+      is_random_related_products,\r\n+      safe_checkout,\r\n+      secure_checkout,\r\n+      social_share,\r\n+      encourage_order,\r\n+      encourage_view,\r\n+      is_corporate_only\r\n+    } = req.body;\r\n \r\n-  fieldsToUpdate.forEach(field => {\r\n-    if (req.body[field] !== undefined) {\r\n-      product[field] = req.body[field];\r\n+    // Update basic fields\r\n+    if (name !== undefined) product.name = name;\r\n+    if (short_description !== undefined) product.short_description = short_description;\r\n+    if (description !== undefined) product.description = description;\r\n+\r\n+    // Update legacy pricing\r\n+    if (price !== undefined) product.price = parseFloat(price);\r\n+    if (compare_price !== undefined) product.compare_price = compare_price;\r\n+    if (cost_price !== undefined) product.cost_price = cost_price;\r\n+    if (sale_price !== undefined) product.sale_price = sale_price;\r\n+    if (discount !== undefined) product.discount = discount;\r\n+\r\n+    // Update retail pricing structure\r\n+    if (retailPrice !== undefined) {\r\n+      product.retailPrice = {\r\n+        mrp: retailPrice.mrp || product.price,\r\n+        sellingPrice: retailPrice.sellingPrice || product.price,\r\n+        discount: retailPrice.discount || 0,\r\n+        currency: retailPrice.currency || 'INR'\r\n+      };\r\n     }\r\n-  });\r\n \r\n-  const updatedProduct = await product.save();\r\n+    // Update corporate pricing\r\n+    if (corporatePricing !== undefined) {\r\n+      product.corporatePricing = {\r\n+        enabled: corporatePricing.enabled || false,\r\n+        minimumOrderQuantity: corporatePricing.minimumOrderQuantity || 1,\r\n+        priceTiers: corporatePricing.priceTiers || [],\r\n+        customQuoteThreshold: corporatePricing.customQuoteThreshold\r\n+      };\r\n+    }\r\n \r\n-  res.status(200).json({\r\n-    message: 'Product updated successfully',\r\n-    product: updatedProduct\r\n-  });\r\n+    // Update inventory fields\r\n+    if (sku !== undefined) product.sku = sku;\r\n+    if (quantity !== undefined) product.quantity = quantity;\r\n+    if (stock_status !== undefined) product.stock_status = stock_status;\r\n+    if (type !== undefined) product.type = type;\r\n+    if (unit !== undefined) product.unit = unit;\r\n+    if (weight !== undefined) product.weight = weight;\r\n+    if (requires_shipping !== undefined) product.requires_shipping = requires_shipping;\r\n+    if (available_from !== undefined) product.available_from = available_from;\r\n+    if (available_to !== undefined) product.available_to = available_to;\r\n+\r\n+    // Update categories and tags\r\n+    if (categories !== undefined) product.categories = categories;\r\n+    if (tags !== undefined) product.tags = tags;\r\n+\r\n+    // Update images\r\n+    if (images !== undefined) product.images = images;\r\n+    if (product_thumbnail_id !== undefined) product.product_thumbnail_id = product_thumbnail_id;\r\n+    if (product_galleries_id !== undefined) product.product_galleries_id = product_galleries_id;\r\n+    if (size_chart_image_id !== undefined) product.size_chart_image_id = size_chart_image_id;\r\n+\r\n+    // Update SEO\r\n+    if (meta_title !== undefined) product.meta_title = meta_title;\r\n+    if (meta_description !== undefined) product.meta_description = meta_description;\r\n+    if (product_meta_image_id !== undefined) product.product_meta_image_id = product_meta_image_id;\r\n+\r\n+    // Update shipping and tax\r\n+    if (is_free_shipping !== undefined) product.is_free_shipping = is_free_shipping;\r\n+    if (tax_id !== undefined) product.tax_id = tax_id;\r\n+    if (estimated_delivery_text !== undefined) product.estimated_delivery_text = estimated_delivery_text;\r\n+    if (return_policy_text !== undefined) product.return_policy_text = return_policy_text;\r\n+\r\n+    // Update flags\r\n+    if (is_featured !== undefined) product.is_featured = is_featured;\r\n+    if (is_popular !== undefined) product.is_popular = is_popular;\r\n+    if (is_trending !== undefined) product.is_trending = is_trending;\r\n+    if (is_return !== undefined) product.is_return = is_return;\r\n+    if (status !== undefined) product.status = status;\r\n+\r\n+    // Update new fields\r\n+    if (variations !== undefined) product.variations = variations;\r\n+    if (related_products !== undefined) product.related_products = related_products;\r\n+    if (cross_sell_products !== undefined) product.cross_sell_products = cross_sell_products;\r\n+    if (is_random_related_products !== undefined) product.is_random_related_products = is_random_related_products;\r\n+    if (safe_checkout !== undefined) product.safe_checkout = safe_checkout;\r\n+    if (secure_checkout !== undefined) product.secure_checkout = secure_checkout;\r\n+    if (social_share !== undefined) product.social_share = social_share;\r\n+    if (encourage_order !== undefined) product.encourage_order = encourage_order;\r\n+    if (encourage_view !== undefined) product.encourage_view = encourage_view;\r\n+    if (is_corporate_only !== undefined) product.is_corporate_only = is_corporate_only;\r\n+\r\n+    // Set updatedBy field\r\n+    product.updatedBy = req.user?.id || req.adminUser?.id;\r\n+\r\n+    const updatedProduct = await product.save();\r\n+\r\n+    res.status(200).json({\r\n+      message: 'Product updated successfully',\r\n+      product: updatedProduct\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error updating product:', error);\r\n+    res.status(500).json({\r\n+      message: 'Internal server error while updating product',\r\n+      error: error.message\r\n+    });\r\n+  }\r\n });\r\n \r\n // @desc    Delete a product\r\n // @route   DELETE /api/products/:id\r\n@@ -368,14 +709,144 @@\n                    parseInt(quantity) >= product.corporatePricing.customQuoteThreshold\r\n   });\r\n });\r\n \r\n+// @desc    Get product analytics\r\n+// @route   GET /api/products/:id/analytics\r\n+// @access  Private (Admin only)\r\n+const getProductAnalytics = asyncHandler(async (req, res) => {\r\n+  try {\r\n+    const product = await Product.findById(req.params.id).select('analytics name sku');\r\n+    if (!product) {\r\n+      return res.status(404).json({ message: 'Product not found' });\r\n+    }\r\n+\r\n+    const analytics = product.analytics || {};\r\n+    \r\n+    // Calculate additional metrics\r\n+    const totalViews = analytics.views?.total || 0;\r\n+    const weeklyViews = analytics.weeklyViews || 0;\r\n+    const monthlyViews = analytics.monthlyViews || 0;\r\n+    \r\n+    // Calculate view breakdown percentages\r\n+    const viewBreakdown = {\r\n+      corporate: ((analytics.views?.corporate || 0) / totalViews * 100) || 0,\r\n+      individual: ((analytics.views?.individual || 0) / totalViews * 100) || 0,\r\n+      anonymous: ((analytics.views?.anonymous || 0) / totalViews * 100) || 0\r\n+    };\r\n+\r\n+    // Get daily views for last 30 days\r\n+    const dailyViews = analytics.dailyViews || [];\r\n+    const last30Days = dailyViews.slice(-30);\r\n+\r\n+    res.status(200).json({\r\n+      productId: product._id,\r\n+      productName: product.name,\r\n+      sku: product.sku,\r\n+      analytics: {\r\n+        totalViews,\r\n+        weeklyViews,\r\n+        monthlyViews,\r\n+        lastViewed: analytics.lastViewed,\r\n+        popularityScore: analytics.popularityScore || 0,\r\n+        viewBreakdown,\r\n+        dailyViews: last30Days,\r\n+        trends: {\r\n+          dailyAverage: last30Days.length > 0 ? \r\n+            last30Days.reduce((sum, day) => sum + (day.count || 0), 0) / last30Days.length : 0,\r\n+          peakDay: last30Days.reduce((max, day) => \r\n+            (day.count || 0) > (max.count || 0) ? day : max, { count: 0, date: null })\r\n+        }\r\n+      }\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error fetching product analytics:', error);\r\n+    res.status(500).json({\r\n+      message: 'Internal server error while fetching analytics',\r\n+      error: error.message\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// @desc    Bulk update product status\r\n+// @route   PUT /api/products/bulk/status\r\n+// @access  Private (Admin only)\r\n+const bulkUpdateProductStatus = asyncHandler(async (req, res) => {\r\n+  try {\r\n+    const { productIds, status, action } = req.body;\r\n+\r\n+    if (!productIds || !Array.isArray(productIds) || productIds.length === 0) {\r\n+      return res.status(400).json({ message: 'Product IDs array is required' });\r\n+    }\r\n+\r\n+    let updateData = {};\r\n+    \r\n+    switch (action) {\r\n+      case 'activate':\r\n+        updateData.status = true;\r\n+        break;\r\n+      case 'deactivate':\r\n+        updateData.status = false;\r\n+        break;\r\n+      case 'feature':\r\n+        updateData.is_featured = true;\r\n+        break;\r\n+      case 'unfeature':\r\n+        updateData.is_featured = false;\r\n+        break;\r\n+      case 'mark_popular':\r\n+        updateData.is_popular = true;\r\n+        break;\r\n+      case 'unmark_popular':\r\n+        updateData.is_popular = false;\r\n+        break;\r\n+      case 'mark_trending':\r\n+        updateData.is_trending = true;\r\n+        break;\r\n+      case 'unmark_trending':\r\n+        updateData.is_trending = false;\r\n+        break;\r\n+      case 'custom_status':\r\n+        if (status !== undefined) updateData.status = status;\r\n+        break;\r\n+      default:\r\n+        return res.status(400).json({ message: 'Invalid action specified' });\r\n+    }\r\n+\r\n+    const result = await Product.updateMany(\r\n+      { _id: { $in: productIds } },\r\n+      { \r\n+        $set: {\r\n+          ...updateData,\r\n+          updatedBy: req.user?.id || req.adminUser?.id,\r\n+          updatedAt: new Date()\r\n+        }\r\n+      }\r\n+    );\r\n+\r\n+    res.status(200).json({\r\n+      message: `Successfully updated ${result.modifiedCount} products`,\r\n+      modifiedCount: result.modifiedCount,\r\n+      action,\r\n+      productIds\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error in bulk update:', error);\r\n+    res.status(500).json({\r\n+      message: 'Internal server error during bulk update',\r\n+      error: error.message\r\n+    });\r\n+  }\r\n+});\r\n+\r\n module.exports = {\r\n   createProduct,\r\n   getAllProducts,\r\n   getProductById,\r\n   updateProduct,\r\n   deleteProduct,\r\n   getProductMeta,\r\n   getCorporateProducts,\r\n-  getProductPricing\r\n+  getProductPricing,\r\n+  getProductAnalytics,\r\n+  bulkUpdateProductStatus\r\n };\r\n"
                },
                {
                    "date": 1753725076279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,14 +159,17 @@\n \r\n     const savedProduct = await product.save();\r\n \r\n     res.status(201).json({\r\n+      success: true,\r\n       message: 'Product created successfully',\r\n+      data: savedProduct,\r\n       product: savedProduct\r\n     });\r\n   } catch (error) {\r\n     console.error('Error creating product:', error);\r\n     res.status(500).json({\r\n+      success: false,\r\n       message: 'Internal server error while creating product',\r\n       error: error.message\r\n     });\r\n   }\r\n@@ -296,9 +299,12 @@\n       return productObj;\r\n     });\r\n \r\n     res.status(200).json({ \r\n+      success: true,\r\n+      data: enhancedProducts,\r\n       products: enhancedProducts,\r\n+      count: enhancedProducts.length,\r\n       pagination: {\r\n         currentPage: parseInt(page),\r\n         totalPages: Math.ceil(totalProducts / parseInt(limit)),\r\n         totalProducts,\r\n@@ -319,8 +325,9 @@\n     });\r\n   } catch (error) {\r\n     console.error('Error fetching products:', error);\r\n     res.status(500).json({\r\n+      success: false,\r\n       message: 'Internal server error while fetching products',\r\n       error: error.message\r\n     });\r\n   }\r\n@@ -440,8 +447,10 @@\n       );\r\n     }\r\n \r\n     res.status(200).json({ \r\n+      success: true,\r\n+      data: productObj,\r\n       product: productObj,\r\n       viewTracked: true,\r\n       userAccess: {\r\n         canPurchase: !productObj.is_corporate_only || userType === 'corporate',\r\n@@ -451,8 +460,9 @@\n     });\r\n   } catch (error) {\r\n     console.error('Error fetching product:', error);\r\n     res.status(500).json({\r\n+      success: false,\r\n       message: 'Internal server error while fetching product',\r\n       error: error.message\r\n     });\r\n   }\r\n@@ -607,14 +617,17 @@\n \r\n     const updatedProduct = await product.save();\r\n \r\n     res.status(200).json({\r\n+      success: true,\r\n       message: 'Product updated successfully',\r\n+      data: updatedProduct,\r\n       product: updatedProduct\r\n     });\r\n   } catch (error) {\r\n     console.error('Error updating product:', error);\r\n     res.status(500).json({\r\n+      success: false,\r\n       message: 'Internal server error while updating product',\r\n       error: error.message\r\n     });\r\n   }\r\n@@ -629,18 +642,23 @@\n   if (!product) {\r\n     return res.status(404).json({ message: 'Product not found' });\r\n   }\r\n   await product.deleteOne();\r\n-  res.status(200).json({ message: 'Product deleted successfully' });\r\n+  res.status(200).json({ \r\n+    success: true,\r\n+    message: 'Product deleted successfully' \r\n+  });\r\n });\r\n \r\n // @desc    Get product meta (categories)\r\n // @route   GET /api/products/meta\r\n // @access  Public\r\n const getProductMeta = asyncHandler(async (req, res) => {\r\n   const categories = await Product.distinct('categories');\r\n   res.status(200).json({\r\n+    success: true,\r\n     message: 'Meta data fetched successfully',\r\n+    data: { categories },\r\n     categories\r\n   });\r\n });\r\n \r\n@@ -681,8 +699,10 @@\n     return productObj;\r\n   });\r\n \r\n   res.status(200).json({ \r\n+    success: true,\r\n+    data: productsWithCorporatePricing,\r\n     products: productsWithCorporatePricing,\r\n     count: productsWithCorporatePricing.length\r\n   });\r\n });\r\n@@ -701,8 +721,16 @@\n \r\n   const pricingInfo = getProductPrice(product.toObject(), userType.toLowerCase(), parseInt(quantity));\r\n   \r\n   res.status(200).json({\r\n+    success: true,\r\n+    data: {\r\n+      productId: product._id,\r\n+      quantity: parseInt(quantity),\r\n+      pricing: pricingInfo,\r\n+      requiresQuote: product.corporatePricing?.customQuoteThreshold && \r\n+                     parseInt(quantity) >= product.corporatePricing.customQuoteThreshold\r\n+    },\r\n     productId: product._id,\r\n     quantity: parseInt(quantity),\r\n     pricing: pricingInfo,\r\n     requiresQuote: product.corporatePricing?.customQuoteThreshold && \r\n@@ -837,8 +865,44 @@\n     });\r\n   }\r\n });\r\n \r\n+// @desc    Get all categories\r\n+// @route   GET /api/products/categories\r\n+// @access  Public\r\n+const getCategories = asyncHandler(async (req, res) => {\r\n+  try {\r\n+    let categories = [];\r\n+    \r\n+    try {\r\n+      const Category = require('../models/Category');\r\n+      categories = await Category.find({ status: true })\r\n+        .select('name slug parent')\r\n+        .populate('parent', 'name slug')\r\n+        .sort({ name: 1 });\r\n+    } catch (modelError) {\r\n+      console.log('Category model not found, extracting from products...');\r\n+      categories = await Product.distinct('categories');\r\n+    }\r\n+    \r\n+    res.status(200).json({\r\n+      success: true,\r\n+      data: categories,\r\n+      categories: categories,\r\n+      count: categories.length\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error fetching categories:', error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      message: 'Error fetching categories',\r\n+      error: error.message,\r\n+      data: [],\r\n+      categories: []\r\n+    });\r\n+  }\r\n+});\r\n+\r\n module.exports = {\r\n   createProduct,\r\n   getAllProducts,\r\n   getProductById,\r\n@@ -847,6 +911,7 @@\n   getProductMeta,\r\n   getCorporateProducts,\r\n   getProductPricing,\r\n   getProductAnalytics,\r\n-  bulkUpdateProductStatus\r\n+  bulkUpdateProductStatus,\r\n+  getCategories\r\n };\r\n"
                },
                {
                    "date": 1753725402807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -865,44 +865,8 @@\n     });\r\n   }\r\n });\r\n \r\n-// @desc    Get all categories\r\n-// @route   GET /api/products/categories\r\n-// @access  Public\r\n-const getCategories = asyncHandler(async (req, res) => {\r\n-  try {\r\n-    let categories = [];\r\n-    \r\n-    try {\r\n-      const Category = require('../models/Category');\r\n-      categories = await Category.find({ status: true })\r\n-        .select('name slug parent')\r\n-        .populate('parent', 'name slug')\r\n-        .sort({ name: 1 });\r\n-    } catch (modelError) {\r\n-      console.log('Category model not found, extracting from products...');\r\n-      categories = await Product.distinct('categories');\r\n-    }\r\n-    \r\n-    res.status(200).json({\r\n-      success: true,\r\n-      data: categories,\r\n-      categories: categories,\r\n-      count: categories.length\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Error fetching categories:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      message: 'Error fetching categories',\r\n-      error: error.message,\r\n-      data: [],\r\n-      categories: []\r\n-    });\r\n-  }\r\n-});\r\n-\r\n module.exports = {\r\n   createProduct,\r\n   getAllProducts,\r\n   getProductById,\r\n@@ -911,7 +875,6 @@\n   getProductMeta,\r\n   getCorporateProducts,\r\n   getProductPricing,\r\n   getProductAnalytics,\r\n-  bulkUpdateProductStatus,\r\n-  getCategories\r\n+  bulkUpdateProductStatus\r\n };\r\n"
                },
                {
                    "date": 1753728944358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,106 +179,184 @@\n // @route   GET /api/products\r\n // @access  Public\r\n const getAllProducts = asyncHandler(async (req, res) => {\r\n   try {\r\n+    console.log('ðŸŒ getAllProducts called with query:', req.query);\r\n+    \r\n     const { \r\n       page = 1, \r\n-      limit = 10, \r\n+      limit = 50,  // Increased default limit for admin\r\n       category, \r\n       featured, \r\n       popular, \r\n       trending, \r\n-      status = true,\r\n+      status,     // Remove default value\r\n       userType,\r\n       corporateOnly,\r\n       minPrice,\r\n       maxPrice,\r\n       stockStatus,\r\n-      search\r\n+      search,\r\n+      adminView   // Add admin flag\r\n     } = req.query;\r\n \r\n     // Build filter object\r\n     const filter = {};\r\n     \r\n-    // Status filter (default to active products)\r\n-    filter.status = status === 'true';\r\n+    // Check if this is an admin request\r\n+    const isAdminRequest = adminView === 'true' || req.headers['x-admin-request'] === 'true';\r\n     \r\n-    // Category filter\r\n-    if (category) {\r\n-      filter.categories = { $in: [category] };\r\n+    if (isAdminRequest) {\r\n+      console.log('ðŸ‘¨â€ðŸ’¼ Admin request detected - minimal filtering applied');\r\n+      \r\n+      // For admin, only apply search filter if provided\r\n+      if (search && search.trim()) {\r\n+        filter.$or = [\r\n+          { name: { $regex: search, $options: 'i' } },\r\n+          { description: { $regex: search, $options: 'i' } },\r\n+          { short_description: { $regex: search, $options: 'i' } },\r\n+          { sku: { $regex: search, $options: 'i' } }\r\n+        ];\r\n+        console.log('ðŸ” Admin search filter applied:', search);\r\n+      }\r\n+      \r\n+      // Admin can explicitly filter by status if needed\r\n+      if (status !== undefined && status !== 'all') {\r\n+        filter.status = status === 'true';\r\n+        console.log('ðŸ“‹ Admin status filter applied:', filter.status);\r\n+      }\r\n+      \r\n+      // Admin can filter by category if needed\r\n+      if (category && category !== 'all') {\r\n+        filter.categories = { $in: [category] };\r\n+        console.log('ðŸ“ Admin category filter applied:', category);\r\n+      }\r\n+    } else {\r\n+      // For public/frontend requests, apply all filters as before\r\n+      console.log('ðŸ‘¥ Public request - full filtering applied');\r\n+      \r\n+      // Status filter (default to active products for public)\r\n+      filter.status = status === 'false' ? false : true;\r\n+      \r\n+      // Category filter\r\n+      if (category) {\r\n+        filter.categories = { $in: [category] };\r\n+      }\r\n+      \r\n+      // Flag filters\r\n+      if (featured === 'true') filter.is_featured = true;\r\n+      if (popular === 'true') filter.is_popular = true;\r\n+      if (trending === 'true') filter.is_trending = true;\r\n+      \r\n+      // Corporate filter\r\n+      if (corporateOnly === 'true') {\r\n+        filter.is_corporate_only = true;\r\n+      } else if (userType !== 'corporate') {\r\n+        // Hide corporate-only products from individual users\r\n+        filter.is_corporate_only = { $ne: true };\r\n+      }\r\n+      \r\n+      // Price range filter\r\n+      if (minPrice || maxPrice) {\r\n+        filter.price = {};\r\n+        if (minPrice) filter.price.$gte = parseFloat(minPrice);\r\n+        if (maxPrice) filter.price.$lte = parseFloat(maxPrice);\r\n+      }\r\n+      \r\n+      // Stock status filter\r\n+      if (stockStatus) {\r\n+        filter.stock_status = stockStatus;\r\n+      }\r\n+      \r\n+      // Search filter\r\n+      if (search) {\r\n+        filter.$or = [\r\n+          { name: { $regex: search, $options: 'i' } },\r\n+          { description: { $regex: search, $options: 'i' } },\r\n+          { short_description: { $regex: search, $options: 'i' } },\r\n+          { sku: { $regex: search, $options: 'i' } }\r\n+        ];\r\n+      }\r\n     }\r\n-    \r\n-    // Flag filters\r\n-    if (featured === 'true') filter.is_featured = true;\r\n-    if (popular === 'true') filter.is_popular = true;\r\n-    if (trending === 'true') filter.is_trending = true;\r\n-    \r\n-    // Corporate filter\r\n-    if (corporateOnly === 'true') {\r\n-      filter.is_corporate_only = true;\r\n-    } else if (userType !== 'corporate') {\r\n-      // Hide corporate-only products from individual users\r\n-      filter.is_corporate_only = { $ne: true };\r\n-    }\r\n-    \r\n-    // Price range filter\r\n-    if (minPrice || maxPrice) {\r\n-      filter.price = {};\r\n-      if (minPrice) filter.price.$gte = parseFloat(minPrice);\r\n-      if (maxPrice) filter.price.$lte = parseFloat(maxPrice);\r\n-    }\r\n-    \r\n-    // Stock status filter\r\n-    if (stockStatus) {\r\n-      filter.stock_status = stockStatus;\r\n-    }\r\n-    \r\n-    // Search filter\r\n-    if (search) {\r\n-      filter.$or = [\r\n-        { name: { $regex: search, $options: 'i' } },\r\n-        { description: { $regex: search, $options: 'i' } },\r\n-        { short_description: { $regex: search, $options: 'i' } },\r\n-        { sku: { $regex: search, $options: 'i' } }\r\n-      ];\r\n-    }\r\n \r\n+    console.log('ðŸ” Final filter object:', JSON.stringify(filter, null, 2));\r\n+\r\n     // Calculate pagination\r\n     const skip = (parseInt(page) - 1) * parseInt(limit);\r\n+    console.log('ðŸ“„ Pagination:', { page: parseInt(page), limit: parseInt(limit), skip });\r\n     \r\n-    // Get products with pagination\r\n-    const products = await Product.find(filter)\r\n-      .populate([\r\n-        {\r\n-          path: 'categories',\r\n-          select: 'name slug parent',\r\n-          populate: {\r\n-            path: 'parent',\r\n-            model: 'Category',\r\n-            select: 'name slug'\r\n-          }\r\n-        },\r\n-        {\r\n-          path: 'related_products',\r\n-          select: 'name price images stock_status',\r\n-          match: { status: true }\r\n-        },\r\n-        {\r\n-          path: 'cross_sell_products',\r\n-          select: 'name price images stock_status',\r\n-          match: { status: true }\r\n-        }\r\n-      ])\r\n-      .sort({ createdAt: -1 })\r\n-      .skip(skip)\r\n-      .limit(parseInt(limit));\r\n-\r\n-    // Get total count for pagination\r\n+    // Get total count\r\n     const totalProducts = await Product.countDocuments(filter);\r\n+    console.log(`ðŸ“Š Total products matching filter: ${totalProducts}`);\r\n     \r\n+    // For admin, get products with minimal population to avoid errors\r\n+    // For public, get products with full population\r\n+    let products;\r\n+    \r\n+    try {\r\n+      if (isAdminRequest) {\r\n+        // Admin gets all data with basic population\r\n+        products = await Product.find(filter)\r\n+          .sort({ createdAt: -1 })\r\n+          .skip(skip)\r\n+          .limit(parseInt(limit))\r\n+          .lean(); // Use lean for better performance\r\n+          \r\n+        console.log(`ðŸ“‹ Admin: Retrieved ${products.length} products without population`);\r\n+      } else {\r\n+        // Public gets fully populated data\r\n+        products = await Product.find(filter)\r\n+          .populate([\r\n+            {\r\n+              path: 'categories',\r\n+              select: 'name slug parent',\r\n+              populate: {\r\n+                path: 'parent',\r\n+                model: 'Category',\r\n+                select: 'name slug'\r\n+              }\r\n+            },\r\n+            {\r\n+              path: 'related_products',\r\n+              select: 'name price images stock_status',\r\n+              match: { status: true }\r\n+            },\r\n+            {\r\n+              path: 'cross_sell_products',\r\n+              select: 'name price images stock_status',\r\n+              match: { status: true }\r\n+            }\r\n+          ])\r\n+          .sort({ createdAt: -1 })\r\n+          .skip(skip)\r\n+          .limit(parseInt(limit));\r\n+          \r\n+        console.log(`ðŸ“‹ Public: Retrieved ${products.length} products with population`);\r\n+      }\r\n+      \r\n+      if (products.length > 0) {\r\n+        console.log('ðŸ” First product sample:', {\r\n+          id: products[0]._id,\r\n+          name: products[0].name,\r\n+          price: products[0].price,\r\n+          status: products[0].status,\r\n+          categories: products[0].categories\r\n+        });\r\n+      }\r\n+    } catch (populateError) {\r\n+      console.error('âš ï¸ Population failed, falling back to basic query:', populateError.message);\r\n+      // Fallback without population\r\n+      products = await Product.find(filter)\r\n+        .sort({ createdAt: -1 })\r\n+        .skip(skip)\r\n+        .limit(parseInt(limit))\r\n+        .lean();\r\n+    }\r\n+    \r\n     // Add calculated fields for frontend\r\n     const enhancedProducts = products.map(product => {\r\n-      const productObj = product.toObject();\r\n+      // For admin, add more detailed information\r\n+      const productObj = product.toObject ? product.toObject() : product;\r\n       \r\n       // Add pricing summary\r\n       productObj.pricingSummary = {\r\n         hasRetailPrice: !!(productObj.retailPrice?.sellingPrice),\r\n@@ -295,16 +373,30 @@\n         allowsPreOrder: productObj.stock_status === 'pre_order',\r\n         allowsBackOrder: productObj.stock_status === 'back_order'\r\n       };\r\n       \r\n+      // For admin, add management flags\r\n+      if (isAdminRequest) {\r\n+        productObj.adminInfo = {\r\n+          canEdit: true,\r\n+          canDelete: true,\r\n+          canDuplicate: true,\r\n+          lastUpdated: productObj.updatedAt,\r\n+          createdBy: productObj.createdBy,\r\n+          updatedBy: productObj.updatedBy\r\n+        };\r\n+      }\r\n+      \r\n       return productObj;\r\n     });\r\n \r\n-    res.status(200).json({ \r\n+    const responseData = {\r\n       success: true,\r\n       data: enhancedProducts,\r\n-      products: enhancedProducts,\r\n+      products: enhancedProducts, // Backward compatibility\r\n       count: enhancedProducts.length,\r\n+      totalCount: totalProducts,\r\n+      isAdminView: isAdminRequest,\r\n       pagination: {\r\n         currentPage: parseInt(page),\r\n         totalPages: Math.ceil(totalProducts / parseInt(limit)),\r\n         totalProducts,\r\n@@ -319,17 +411,34 @@\n         trending,\r\n         corporateOnly,\r\n         priceRange: { minPrice, maxPrice },\r\n         stockStatus,\r\n-        search\r\n+        search,\r\n+        appliedFilter: filter,\r\n+        isAdminRequest\r\n+      },\r\n+      debug: {\r\n+        queryReceived: req.query,\r\n+        filterApplied: filter,\r\n+        totalInDatabase: totalProducts,\r\n+        retrievedCount: products.length,\r\n+        adminView: isAdminRequest,\r\n+        timestamp: new Date().toISOString()\r\n       }\r\n-    });\r\n+    };\r\n+\r\n+    console.log('âœ… Sending response with', enhancedProducts.length, 'products');\r\n+    res.status(200).json(responseData);\r\n+    \r\n   } catch (error) {\r\n-    console.error('Error fetching products:', error);\r\n+    console.error('âŒ Error in getAllProducts:', error);\r\n     res.status(500).json({\r\n       success: false,\r\n       message: 'Internal server error while fetching products',\r\n-      error: error.message\r\n+      error: error.message,\r\n+      data: [],\r\n+      products: [],\r\n+      count: 0\r\n     });\r\n   }\r\n });\r\n \r\n"
                }
            ],
            "date": 1753640078106,
            "name": "Commit-0",
            "content": "const Product = require('../models/Product');\r\nconst asyncHandler = require('express-async-handler');\r\nconst { getProductPrice } = require('../utils/productPricing');\r\n\r\n// @desc    Create a new product\r\n// @route   POST /api/products\r\n// @access  Private (Admin only)\r\nconst createProduct = asyncHandler(async (req, res) => {\r\n  try {\r\n    const {\r\n      name,\r\n      short_description,\r\n      description,\r\n      price,\r\n      compare_price,\r\n      cost_price,\r\n      sale_price,\r\n      discount,\r\n      // New retail pricing fields (optional)\r\n      retailPrice,\r\n      // Corporate pricing fields (optional)\r\n      corporatePricing,\r\n      sku,\r\n      quantity,\r\n      stock_status,\r\n      type,\r\n      unit,\r\n      weight,\r\n      requires_shipping,\r\n      available_from,\r\n      available_to,\r\n      categories,\r\n      tags,\r\n      images,\r\n      product_thumbnail_id,\r\n      product_galleries_id,\r\n      size_chart_image_id,\r\n      meta_title,\r\n      meta_description,\r\n      product_meta_image_id,\r\n      is_free_shipping,\r\n      tax_id,\r\n      estimated_delivery_text,\r\n      return_policy_text,\r\n      is_featured,\r\n      is_popular,\r\n      is_trending,\r\n      is_return,\r\n      status\r\n    } = req.body;\r\n\r\n    // Required fields check\r\n    if (!name || !description || !price || !categories || !categories.length) {\r\n      return res.status(400).json({\r\n        message: 'Missing required fields: name, description, price, or categories'\r\n      });\r\n    }\r\n\r\n    const product = new Product({\r\n      name,\r\n      short_description,\r\n      description,\r\n\r\n      // Legacy Pricing (required for backward compatibility)\r\n      price: parseFloat(price),\r\n      compare_price,\r\n      cost_price,\r\n      sale_price,\r\n      discount,\r\n\r\n      // New Retail Pricing (optional, will default to legacy price)\r\n      retailPrice: retailPrice ? {\r\n        mrp: retailPrice.mrp || parseFloat(price),\r\n        sellingPrice: retailPrice.sellingPrice || parseFloat(price),\r\n        discount: retailPrice.discount || 0,\r\n        currency: retailPrice.currency || 'INR'\r\n      } : {\r\n        mrp: parseFloat(price),\r\n        sellingPrice: parseFloat(price),\r\n        discount: 0,\r\n        currency: 'INR'\r\n      },\r\n\r\n      // Corporate Pricing (optional)\r\n      corporatePricing: corporatePricing ? {\r\n        enabled: corporatePricing.enabled || false,\r\n        minimumOrderQuantity: corporatePricing.minimumOrderQuantity || 1,\r\n        priceTiers: corporatePricing.priceTiers || [],\r\n        customQuoteThreshold: corporatePricing.customQuoteThreshold\r\n      } : {\r\n        enabled: false,\r\n        minimumOrderQuantity: 1,\r\n        priceTiers: []\r\n      },\r\n\r\n      // Inventory\r\n      sku,\r\n      quantity,\r\n      stock_status,\r\n      type: type || 'simple',\r\n      unit,\r\n      weight,\r\n      requires_shipping,\r\n      available_from,\r\n      available_to,\r\n\r\n      // Categories & Tags\r\n      categories,\r\n      tags,\r\n\r\n      // Images\r\n      images,\r\n      product_thumbnail_id,\r\n      product_galleries_id,\r\n      size_chart_image_id,\r\n\r\n      // SEO\r\n      meta_title: meta_title || name,\r\n      meta_description,\r\n      product_meta_image_id,\r\n\r\n      // Shipping & Tax\r\n      is_free_shipping,\r\n      tax_id,\r\n      estimated_delivery_text,\r\n      return_policy_text,\r\n\r\n      // Flags\r\n      is_featured,\r\n      is_popular,\r\n      is_trending,\r\n      is_return,\r\n      status\r\n    });\r\n\r\n    const savedProduct = await product.save();\r\n\r\n    res.status(201).json({\r\n      message: 'Product created successfully',\r\n      product: savedProduct\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    res.status(500).json({\r\n      message: 'Internal server error while creating product',\r\n      error: error.message\r\n    });\r\n  }\r\n});\r\n\r\n// @desc    Get all products\r\n// @route   GET /api/products\r\n// @access  Public\r\nconst getAllProducts = asyncHandler(async (req, res) => {\r\n  const products = await Product.find().populate({\r\n    path: 'categories',\r\n    populate: {\r\n      path: 'parent',\r\n      model: 'Category'\r\n    }\r\n  });\r\n  res.status(200).json({ products });\r\n});\r\n\r\n// @desc    Get product by ID\r\n// @route   GET /api/products/:id\r\n// @access  Public\r\nconst getProductById = asyncHandler(async (req, res) => {\r\n  const product = await Product.findById(req.params.id).populate({\r\n    path: 'categories',\r\n    populate: {\r\n      path: 'parent',\r\n      model: 'Category'\r\n    }\r\n  });\r\n  if (!product) {\r\n    return res.status(404).json({ message: 'Product not found' });\r\n  }\r\n  res.status(200).json({ product });\r\n});\r\n\r\n// @desc    Update a product\r\n// @route   PUT /api/products/:id\r\n// @access  Private (Admin only)\r\nconst updateProduct = asyncHandler(async (req, res) => {\r\n  const productId = req.params.id;\r\n  const product = await Product.findById(productId);\r\n  if (!product) {\r\n    return res.status(404).json({ message: 'Product not found' });\r\n  }\r\n\r\n  // Only update fields present in the Product schema\r\n  const fieldsToUpdate = [\r\n    'name',\r\n    'short_description',\r\n    'description',\r\n    'price',\r\n    'compare_price',\r\n    'cost_price',\r\n    'sale_price',\r\n    'discount',\r\n    'retailPrice',           // New field\r\n    'corporatePricing',      // New field\r\n    'sku',\r\n    'quantity',\r\n    'stock_status',\r\n    'type',\r\n    'unit',\r\n    'weight',\r\n    'requires_shipping',\r\n    'available_from',\r\n    'available_to',\r\n    'categories',\r\n    'tags',\r\n    'images',\r\n    'product_thumbnail_id',\r\n    'product_galleries_id',\r\n    'size_chart_image_id',\r\n    'meta_title',\r\n    'meta_description',\r\n    'product_meta_image_id',\r\n    'is_free_shipping',\r\n    'tax_id',\r\n    'estimated_delivery_text',\r\n    'return_policy_text',\r\n    'is_featured',\r\n    'is_popular',\r\n    'is_trending',\r\n    'is_return',\r\n    'status'\r\n  ];\r\n\r\n  fieldsToUpdate.forEach(field => {\r\n    if (req.body[field] !== undefined) {\r\n      product[field] = req.body[field];\r\n    }\r\n  });\r\n\r\n  const updatedProduct = await product.save();\r\n\r\n  res.status(200).json({\r\n    message: 'Product updated successfully',\r\n    product: updatedProduct\r\n  });\r\n});\r\n\r\n// @desc    Delete a product\r\n// @route   DELETE /api/products/:id\r\n// @access  Private (Admin only)\r\nconst deleteProduct = asyncHandler(async (req, res) => {\r\n  const productId = req.params.id;\r\n  const product = await Product.findById(productId);\r\n  if (!product) {\r\n    return res.status(404).json({ message: 'Product not found' });\r\n  }\r\n  await product.deleteOne();\r\n  res.status(200).json({ message: 'Product deleted successfully' });\r\n});\r\n\r\n// @desc    Get product meta (categories)\r\n// @route   GET /api/products/meta\r\n// @access  Public\r\nconst getProductMeta = asyncHandler(async (req, res) => {\r\n  const categories = await Product.distinct('categories');\r\n  res.status(200).json({\r\n    message: 'Meta data fetched successfully',\r\n    categories\r\n  });\r\n});\r\n\r\n// @desc    Get products with corporate pricing\r\n// @route   GET /api/products/corporate\r\n// @access  Private (Corporate users only)\r\nconst getCorporateProducts = asyncHandler(async (req, res) => {\r\n  const { userType } = req.user || {};\r\n  \r\n  if (userType !== 'Corporate') {\r\n    return res.status(403).json({ message: 'Access denied. Corporate account required.' });\r\n  }\r\n\r\n  const products = await Product.find({\r\n    'corporatePricing.enabled': true,\r\n    status: true\r\n  }).populate({\r\n    path: 'categories',\r\n    populate: {\r\n      path: 'parent',\r\n      model: 'Category'\r\n    }\r\n  });\r\n\r\n  // Add pricing information for each product\r\n  const productsWithCorporatePricing = products.map(product => {\r\n    const productObj = product.toObject();\r\n    \r\n    // Add calculated fields for easier frontend consumption\r\n    if (productObj.corporatePricing && productObj.corporatePricing.enabled) {\r\n      const tiers = productObj.corporatePricing.priceTiers || [];\r\n      productObj.lowestCorporatePrice = tiers.length > 0 ? \r\n        Math.min(...tiers.map(tier => tier.pricePerUnit)) : null;\r\n      productObj.minCorporateQuantity = tiers.length > 0 ? \r\n        Math.min(...tiers.map(tier => tier.minQuantity)) : 1;\r\n    }\r\n    \r\n    return productObj;\r\n  });\r\n\r\n  res.status(200).json({ \r\n    products: productsWithCorporatePricing,\r\n    count: productsWithCorporatePricing.length\r\n  });\r\n});\r\n\r\n// @desc    Get product pricing for specific quantity (corporate)\r\n// @route   GET /api/products/:id/pricing\r\n// @access  Private (Corporate users only)\r\nconst getProductPricing = asyncHandler(async (req, res) => {\r\n  const { quantity = 1 } = req.query;\r\n  const { userType } = req.user || {};\r\n  \r\n  const product = await Product.findById(req.params.id);\r\n  if (!product) {\r\n    return res.status(404).json({ message: 'Product not found' });\r\n  }\r\n\r\n  const pricingInfo = getProductPrice(product.toObject(), userType.toLowerCase(), parseInt(quantity));\r\n  \r\n  res.status(200).json({\r\n    productId: product._id,\r\n    quantity: parseInt(quantity),\r\n    pricing: pricingInfo,\r\n    requiresQuote: product.corporatePricing?.customQuoteThreshold && \r\n                   parseInt(quantity) >= product.corporatePricing.customQuoteThreshold\r\n  });\r\n});\r\n\r\nmodule.exports = {\r\n  createProduct,\r\n  getAllProducts,\r\n  getProductById,\r\n  updateProduct,\r\n  deleteProduct,\r\n  getProductMeta,\r\n  getCorporateProducts,\r\n  getProductPricing\r\n};\r\n"
        }
    ]
}