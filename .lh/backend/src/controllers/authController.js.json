{
    "sourceFile": "backend/src/controllers/authController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1752836234312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752836816091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,9 +170,9 @@\n         decryptedData = req.body;\r\n       }\r\n \r\n       const { phone, password } = decryptedData;\r\n-      console.log('ÔøΩ Extracted phone:', phone);\r\n+      console.log('\udcf1 Extracted phone:', phone);\r\n       console.log('üîë Password length:', password?.length || 0);\r\n \r\n       if (!phone || !password) {\r\n         console.log('‚ùå Missing phone or password');\r\n"
                },
                {
                    "date": 1752850645405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,9 +170,9 @@\n         decryptedData = req.body;\r\n       }\r\n \r\n       const { phone, password } = decryptedData;\r\n-      console.log('ÔøΩ Extracted phone:', phone);\r\n+      console.log('\udcf1 Extracted phone:', phone);\r\n       console.log('üîë Password length:', password?.length || 0);\r\n \r\n       if (!phone || !password) {\r\n         console.log('‚ùå Missing phone or password');\r\n"
                }
            ],
            "date": 1752836234312,
            "name": "Commit-0",
            "content": "  const User = require('../models/User');\r\n  const OTP = require('../models/OTP');\r\n  const bcrypt = require('bcrypt');\r\n  const jwt = require('jsonwebtoken');\r\n  const crypto = require('crypto');\r\n  const sendEmail = require('../utils/sendEmail');\r\n  const { encryptData, decryptData } = require('../utils/cryptoUtil');\r\n\r\n  // ‚úÖ SIGNUP CONTROLLER\r\nconst signupUser = async (req, res) => {\r\n  try {\r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('üîì Decrypting signup data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const {\r\n      name,\r\n      email,\r\n      phone,\r\n      password,\r\n      confirmPassword,\r\n      otp,\r\n      userType,\r\n      companyDetails,\r\n      role,\r\n      gender,\r\n      dob,\r\n      pincode\r\n    } = decryptedData;\r\n\r\n    console.log('üìù Signup attempt for phone:', phone);\r\n\r\n  // 1. Basic required fields validation\r\n  if (\r\n    !name ||\r\n    !phone ||\r\n    !password ||\r\n    !confirmPassword ||\r\n    !otp ||\r\n    !userType ||\r\n    !gender ||\r\n    !dob ||\r\n    !pincode\r\n  ) {\r\n    return res.status(400).json({ error: 'Missing required fields' });\r\n  }\r\n\r\n  // 2. Password match check\r\n  if (password !== confirmPassword) {\r\n    return res.status(400).json({ error: 'Password and Confirm Password do not match' });\r\n  }\r\n\r\n  // 3. Corporate user validation\r\n  if (userType === 'corporate') {\r\n    if (\r\n      !companyDetails ||\r\n      !companyDetails.companyName ||\r\n      !companyDetails.gstNumber ||\r\n      !companyDetails.address\r\n    ) {\r\n      return res.status(400).json({ error: 'Corporate details are required' });\r\n    }\r\n  }\r\n\r\n  try {\r\n    // 4. Check if user already exists\r\n    const existingUser = await User.findOne({ phone });\r\n    if (existingUser) {\r\n      return res.status(400).json({ error: 'User already exists' });\r\n    }\r\n\r\n    // 5. Admin role restriction\r\n    if ((role === 'admin' || role === 'tempAdmin') && (!email || !email.endsWith('@zyftoo.com'))) {\r\n      return res.status(403).json({ error: 'Only @zyftoo.com emails allowed for admin roles' });\r\n    }\r\n\r\n    // 6. Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // 7. Email verification token\r\n    const emailVerificationToken = crypto.randomBytes(20).toString('hex');\r\n\r\n    // 8. Prepare user data\r\n    const newUser = new User({\r\n      name,\r\n      email,\r\n      phone,\r\n      password: hashedPassword,\r\n      userType,\r\n      role: role || 'user',\r\n      gender,\r\n      dob,\r\n      pincode,\r\n      companyDetails: userType === 'corporate' ? {\r\n        companyName: companyDetails.companyName,\r\n        gstNumber: companyDetails.gstNumber,\r\n        address: companyDetails.address\r\n      } : undefined,\r\n      isEmailVerified: false,\r\n      emailVerificationToken\r\n    });\r\n\r\n    await newUser.save();\r\n\r\n    // 9. Send verification email\r\n    const verificationUrl = `http://localhost:5000/api/auth/verify-email/${emailVerificationToken}`;\r\n    console.log(`üîó Email verification URL: ${verificationUrl}`);\r\n\r\n    const html = `\r\n      <p>Hi ${newUser.name},</p>\r\n      <p>Please verify your email by clicking the link below:</p>\r\n      <a href=\"${verificationUrl}\">${verificationUrl}</a>\r\n    `;\r\n\r\n    await sendEmail({\r\n      to: newUser.email,\r\n      subject: 'Verify your email for Zyftoo',\r\n      html,\r\n    });\r\n\r\n    // 10. Remove OTP\r\n    await OTP.deleteMany({ phone, purpose: 'signup' });\r\n\r\n    return res.status(201).json({\r\n      success: true,\r\n      message: 'User registered successfully. Verification email sent.',\r\n      emailVerificationToken // for dev testing\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Signup error:', error);\r\n    return res.status(500).json({ success: false, error: 'Signup failed' });\r\n  }\r\n  } catch (decryptionError) {\r\n    console.error('Decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\n\r\n  // ‚úÖ LOGIN CONTROLLER\r\n  const loginUser = async (req, res) => {\r\n    try {\r\n      // Decrypt the incoming data\r\n      let decryptedData;\r\n      if (req.body.encryptedData) {\r\n        console.log('üîì Decrypting login data...');\r\n        decryptedData = decryptData(req.body.encryptedData);\r\n      } else {\r\n        // Fallback to unencrypted data for backward compatibility\r\n        decryptedData = req.body;\r\n      }\r\n\r\n      const { phone, password } = decryptedData;\r\n      console.log('üîç Login attempt with phone:', phone);\r\n\r\n      if (!phone || !password) {\r\n        return res.status(400).json({ success: false, error: 'Phone and password are required' });\r\n      }\r\n\r\n      try {\r\n        const user = await User.findOne({ phone });\r\n        if (!user) {\r\n          return res.status(401).json({ success: false, error: 'User not found' });\r\n        }\r\n\r\n        const isMatch = await bcrypt.compare(password, user.password);\r\n        if (!isMatch) {\r\n          return res.status(401).json({ success: false, error: 'Invalid password' });\r\n        }\r\n\r\n        const token = jwt.sign(\r\n          { id: user._id, role: user.role },\r\n          process.env.JWT_SECRET,\r\n          { expiresIn: process.env.JWT_EXPIRE }\r\n        );\r\n\r\n        return res.status(200).json({\r\n          success: true,\r\n          message: 'Login successful',\r\n          data: {\r\n            token,\r\n            user: {\r\n              id: user._id,\r\n              name: user.name,\r\n              email: user.email,\r\n              phone: user.phone,\r\n              userType: user.userType,\r\n              role: user.role,\r\n              isEmailVerified: user.isEmailVerified\r\n            }\r\n          }\r\n        });\r\n      } catch (error) {\r\n        console.error('Login error:', error.message);\r\n        return res.status(500).json({ success: false, error: 'Login failed' });\r\n      }\r\n    } catch (decryptionError) {\r\n      console.error('Login decryption error:', decryptionError);\r\n      return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n    }\r\n  };\r\n\r\nconst verifyEmail = async (req, res) => {\r\n  const { token } = req.params;\r\n\r\n  try {\r\n    const user = await User.findOne({ emailVerificationToken: token });\r\n\r\n    if (!user) {\r\n      return res.status(400).json({ error: 'Invalid or expired token' });\r\n    }\r\n\r\n    user.emailVerified  = true;\r\n    user.emailVerificationToken = undefined;\r\n\r\n    await user.save();\r\n\r\n    const updatedUser = await User.findById(user._id); // confirm save\r\n    console.log('‚úÖ Email verified. Current DB state:', updatedUser);\r\n\r\n    return res.status(200).json({ message: 'Email verified successfully' });\r\n  } catch (error) {\r\n    console.error('‚ùå Email verification error:', error.message || error);\r\n    return res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n};\r\n\r\n  // ‚úÖ RESET PASSWORD CONTROLLER\r\n const resetPassword = async (req, res) => {\r\n  try {\r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('üîì Decrypting password reset data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const { phone, newPassword } = decryptedData;\r\n    console.log('üîÑ Password reset attempt for phone:', phone);\r\n\r\n    if (!phone || !newPassword) {\r\n      return res.status(400).json({ success: false, error: 'Phone and new password are required.' });\r\n    }\r\n\r\n    try {\r\n      // Step 1: Find user by phone\r\n      const user = await User.findOne({ phone });\r\n      if (!user) {\r\n        return res.status(404).json({ success: false, error: 'User not found.' });\r\n      }\r\n\r\n      // Step 2: Hash new password\r\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n      // Step 3: Update password only\r\n      user.password = hashedPassword;\r\n      await user.save();\r\n\r\n      // Step 4: Clear OTPs related to password reset (optional but safe)\r\n      await OTP.deleteMany({ phone, purpose: 'reset' });\r\n\r\n      // Step 5: Respond with success\r\n      return res.status(200).json({ success: true, message: 'Password updated successfully.' });\r\n\r\n    } catch (err) {\r\n      console.error('Reset password error:', err.message);\r\n      return res.status(500).json({ success: false, error: 'Server error while resetting password.' });\r\n    }\r\n  } catch (decryptionError) {\r\n    console.error('Password reset decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\nconst checkUser = async (req, res) => {\r\n  try {\r\n    const user = await User.findOne({ phone: req.params.phone });\r\n    return res.status(200).json({ exists: !!user });\r\n  } catch (err) {\r\n    return res.status(500).json({ message: 'Server Error' });\r\n  }\r\n};\r\n\r\n  module.exports = {\r\n    signupUser,\r\n    loginUser,\r\n    resetPassword,\r\n    verifyEmail,\r\n    checkUser,\r\n  };\r\n"
        }
    ]
}