{
    "sourceFile": "backend/src/controllers/otpController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1752836234244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753633460366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,35 @@\n const OTP = require('../models/OTP');\r\n-const User = require('../models/User'); // ✅ ADD THIS\r\n+const User = require('../models/User');\r\n+const sendEmail = require('../utils/sendEmail');\r\n const { encryptData, decryptData } = require('../utils/cryptoUtil');\r\n \r\n const generateOTP = () => {\r\n   return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP\r\n };\r\n \r\n+// Helper function to send OTP via email\r\n+const sendOTPEmail = async (email, otp, purpose) => {\r\n+  const subject = purpose === 'signup' ? 'Verify Your Corporate Registration' : 'Password Reset OTP';\r\n+  const html = `\r\n+    <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n+      <h2>Your OTP Code</h2>\r\n+      <p>Your verification code is:</p>\r\n+      <div style=\"background: #f8f9fa; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; margin: 20px 0;\">\r\n+        ${otp}\r\n+      </div>\r\n+      <p>This code will expire in 5 minutes.</p>\r\n+      <p>If you didn't request this, please ignore this email.</p>\r\n+    </div>\r\n+  `;\r\n+\r\n+  await sendEmail({\r\n+    to: email,\r\n+    subject,\r\n+    html\r\n+  });\r\n+};\r\n+\r\n exports.sendOtp = async (req, res) => {\r\n   try {\r\n     // Decrypt the incoming data\r\n     let decryptedData;\r\n@@ -17,32 +40,83 @@\n       // Fallback to unencrypted data for backward compatibility\r\n       decryptedData = req.body;\r\n     }\r\n \r\n-    const { phone, purpose } = decryptedData;\r\n-    console.log('📲 OTP send request for phone:', phone, 'purpose:', purpose);\r\n+    const { phone, email, purpose, userType } = decryptedData;\r\n+    console.log(`📲 OTP send request for ${email ? `email: ${email}` : `phone: ${phone}`} purpose: ${purpose} userType: ${userType}`);\r\n \r\n-    if (!phone || !purpose) {\r\n-      return res.status(400).json({ success: false, error: 'Phone and purpose are required' });\r\n+    if ((!phone && !email) || !purpose) {\r\n+      return res.status(400).json({ success: false, error: 'Phone/Email and purpose are required' });\r\n     }\r\n \r\n+    // Validate based on userType\r\n+    if (userType === 'Corporate') {\r\n+      if (!email) {\r\n+        return res.status(400).json({ success: false, error: 'Email is required for Corporate users' });\r\n+      }\r\n+    } else {\r\n+      if (!phone) {\r\n+        return res.status(400).json({ success: false, error: 'Phone is required for Individual users' });\r\n+      }\r\n+    }\r\n+\r\n     try {\r\n-      // ✅ Check if user already exists when purpose is \"signup\"\r\n+      // Check if user already exists when purpose is \"signup\"\r\n       if (purpose === 'signup') {\r\n-        const existingUser = await User.findOne({ phone });\r\n+        let existingUser;\r\n+        if (userType === 'Corporate' && email) {\r\n+          existingUser = await User.findOne({ email });\r\n+        } else if (phone) {\r\n+          existingUser = await User.findOne({ phone });\r\n+        }\r\n+        \r\n         if (existingUser) {\r\n           return res.status(409).json({ success: false, error: 'User already exists' });\r\n         }\r\n       }\r\n \r\n       const otp = generateOTP();\r\n-      console.log(`📲 Generating OTP for ${phone} with purpose: ${purpose}`);\r\n+      console.log(`📲 Generating OTP for ${email || phone} with purpose: ${purpose}`);\r\n \r\n-      await OTP.create({ phone, otp, purpose });\r\n+      // Create OTP record\r\n+      const otpData = {\r\n+        otp,\r\n+        purpose,\r\n+        userType: userType || 'Individual'\r\n+      };\r\n \r\n-      console.log(`📲 OTP for ${phone}: ${otp}`);\r\n+      if (email) {\r\n+        otpData.email = email;\r\n+      }\r\n+      if (phone) {\r\n+        otpData.phone = phone;\r\n+      }\r\n \r\n-      return res.status(200).json({ success: true, message: 'OTP sent successfully' });\r\n+      // Clear existing OTPs\r\n+      if (email) {\r\n+        await OTP.deleteMany({ email, purpose });\r\n+      }\r\n+      if (phone) {\r\n+        await OTP.deleteMany({ phone, purpose });\r\n+      }\r\n+\r\n+      // Save new OTP\r\n+      await OTP.create(otpData);\r\n+\r\n+      // Send OTP via appropriate channel\r\n+      if (userType === 'Corporate' && email) {\r\n+        console.log(`📧 OTP for ${email}: ${otp}`);\r\n+        await sendOTPEmail(email, otp, purpose);\r\n+      } else if (phone) {\r\n+        console.log(`📲 OTP for ${phone}: ${otp}`);\r\n+        // SMS sending logic would go here\r\n+      }\r\n+\r\n+      const message = userType === 'Corporate' ? \r\n+        'OTP sent to your email address' : \r\n+        'OTP sent to your phone number';\r\n+\r\n+      return res.status(200).json({ success: true, message });\r\n     } catch (error) {\r\n       console.error('❌ Error sending OTP:', error.message);\r\n       return res.status(500).json({ success: false, error: 'Failed to send OTP' });\r\n     }\r\n@@ -65,26 +139,42 @@\n       // Fallback to unencrypted data for backward compatibility\r\n       decryptedData = req.body;\r\n     }\r\n \r\n-    const { phone, otp, purpose } = decryptedData;\r\n-    console.log('✅ OTP verification for phone:', phone, 'purpose:', purpose);\r\n+    const { phone, email, otp, purpose, userType } = decryptedData;\r\n+    console.log(`✅ OTP verification for ${email ? `email: ${email}` : `phone: ${phone}`} purpose: ${purpose}`);\r\n \r\n-    if (!phone || !otp || !purpose) {\r\n-      return res.status(400).json({ success: false, error: 'Phone, OTP, and purpose are required' });\r\n+    if ((!phone && !email) || !otp || !purpose) {\r\n+      return res.status(400).json({ success: false, error: 'Phone/Email, OTP, and purpose are required' });\r\n     }\r\n \r\n     try {\r\n-      const existingOtp = await OTP.findOne({ phone, otp, purpose });\r\n+      // Build query based on userType\r\n+      let query = { otp, purpose };\r\n+      \r\n+      if (userType === 'Corporate' && email) {\r\n+        query.email = email;\r\n+      } else if (phone) {\r\n+        query.phone = phone;\r\n+      } else {\r\n+        return res.status(400).json({ success: false, error: 'Invalid verification parameters' });\r\n+      }\r\n \r\n+      const existingOtp = await OTP.findOne(query);\r\n+\r\n       if (!existingOtp) {\r\n         return res.status(400).json({ success: false, error: 'Invalid or expired OTP' });\r\n       }\r\n \r\n-      console.log(`✅ OTP verified for ${phone} with purpose: ${purpose}`);\r\n+      console.log(`✅ OTP verified for ${email || phone} with purpose: ${purpose}`);\r\n \r\n-      // ✅ Just verify, don't create user\r\n-      await OTP.deleteMany({ phone, purpose }); // optional: cleanup OTPs\r\n+      // Delete OTP after successful verification\r\n+      if (email) {\r\n+        await OTP.deleteMany({ email, purpose });\r\n+      }\r\n+      if (phone) {\r\n+        await OTP.deleteMany({ phone, purpose });\r\n+      }\r\n \r\n       return res.status(200).json({ success: true, message: 'OTP verified successfully' });\r\n     } catch (error) {\r\n       console.error('❌ Error verifying OTP:', error.message);\r\n"
                },
                {
                    "date": 1753634367507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,25 +30,93 @@\n };\r\n \r\n exports.sendOtp = async (req, res) => {\r\n   try {\r\n-    // Decrypt the incoming data\r\n-    let decryptedData;\r\n-    if (req.body.encryptedData) {\r\n-      console.log('🔓 Decrypting OTP send data...');\r\n-      decryptedData = decryptData(req.body.encryptedData);\r\n+    console.log('📲 OTP send request received');\r\n+    console.log('🔓 Decrypting OTP send data...');\r\n+    \r\n+    const decryptedData = decryptData(req.body.encryptedData);\r\n+    const { phone, email, purpose, userType } = decryptedData;\r\n+\r\n+    console.log(`📲 OTP send request for ${email ? `email: ${email}` : `phone: ${phone}`} purpose: ${purpose} userType: ${userType || 'Individual'}`);\r\n+\r\n+    // Validate based on userType\r\n+    if (userType === 'Corporate') {\r\n+      if (!email) {\r\n+        return res.status(400).json({ message: 'Email is required for Corporate users' });\r\n+      }\r\n     } else {\r\n-      // Fallback to unencrypted data for backward compatibility\r\n-      decryptedData = req.body;\r\n+      if (!phone) {\r\n+        return res.status(400).json({ message: 'Phone is required for Individual users' });\r\n+      }\r\n     }\r\n \r\n-    const { phone, email, purpose, userType } = decryptedData;\r\n-    console.log(`📲 OTP send request for ${email ? `email: ${email}` : `phone: ${phone}`} purpose: ${purpose} userType: ${userType}`);\r\n+    // Generate 6-digit OTP\r\n+    const otpCode = Math.floor(100000 + Math.random() * 900000).toString();\r\n+    console.log(`📲 Generating OTP for ${email || phone} with purpose: ${purpose}`);\r\n \r\n-    if ((!phone && !email) || !purpose) {\r\n-      return res.status(400).json({ success: false, error: 'Phone/Email and purpose are required' });\r\n+    // Create OTP record\r\n+    const otpData = {\r\n+      otp: otpCode,\r\n+      purpose: purpose || 'signup'\r\n+    };\r\n+\r\n+    if (email) {\r\n+      otpData.email = email;\r\n+      // Clear existing OTPs for this email\r\n+      await OTP.deleteMany({ email, purpose: otpData.purpose });\r\n     }\r\n+    if (phone) {\r\n+      otpData.phone = phone;\r\n+      // Clear existing OTPs for this phone\r\n+      await OTP.deleteMany({ phone, purpose: otpData.purpose });\r\n+    }\r\n \r\n+    // Save new OTP\r\n+    const newOTP = new OTP(otpData);\r\n+    await newOTP.save();\r\n+\r\n+    // Send OTP via appropriate channel\r\n+    if (userType === 'Corporate' && email) {\r\n+      // Send OTP via email for corporate users\r\n+      console.log(`📧 OTP for ${email}: ${otpCode}`);\r\n+      \r\n+      const subject = purpose === 'signup' ? 'Verify Your Corporate Registration' : 'Password Reset OTP';\r\n+      const html = `\r\n+        <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Your verification code is:</p>\r\n+          <div style=\"background: #f8f9fa; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; margin: 20px 0;\">\r\n+            ${otpCode}\r\n+          </div>\r\n+          <p>This code will expire in 5 minutes.</p>\r\n+          <p>If you didn't request this, please ignore this email.</p>\r\n+        </div>\r\n+      `;\r\n+\r\n+      await sendEmail({\r\n+        to: email,\r\n+        subject,\r\n+        html\r\n+      });\r\n+    } else if (phone) {\r\n+      // Send OTP via SMS for individual users (for now just log it)\r\n+      console.log(`📲 OTP for ${phone}: ${otpCode}`);\r\n+    }\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      message: userType === 'Corporate' ? \r\n+        'OTP sent to your email address' : \r\n+        'OTP sent to your phone number'\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error('❌ Send OTP error:', error);\r\n+    res.status(500).json({ message: error.message });\r\n+  }\r\n+};\r\n+\r\n     // Validate based on userType\r\n     if (userType === 'Corporate') {\r\n       if (!email) {\r\n         return res.status(400).json({ success: false, error: 'Email is required for Corporate users' });\r\n@@ -128,61 +196,54 @@\n \r\n exports.verifyOtp = async (req, res) => {\r\n   try {\r\n     console.log('🔍 Verifying OTP...');\r\n+    console.log('🔓 Decrypting OTP verification data...');\r\n     \r\n-    // Decrypt the incoming data\r\n-    let decryptedData;\r\n-    if (req.body.encryptedData) {\r\n-      console.log('🔓 Decrypting OTP verification data...');\r\n-      decryptedData = decryptData(req.body.encryptedData);\r\n-    } else {\r\n-      // Fallback to unencrypted data for backward compatibility\r\n-      decryptedData = req.body;\r\n-    }\r\n+    const decryptedData = decryptData(req.body.encryptedData);\r\n+    const { phone, email, otp, purpose, userType } = decryptedData;\r\n \r\n-    const { phone, email, otp, purpose, userType } = decryptedData;\r\n     console.log(`✅ OTP verification for ${email ? `email: ${email}` : `phone: ${phone}`} purpose: ${purpose}`);\r\n \r\n-    if ((!phone && !email) || !otp || !purpose) {\r\n-      return res.status(400).json({ success: false, error: 'Phone/Email, OTP, and purpose are required' });\r\n+    // Build query based on userType\r\n+    let query = { otp, purpose: purpose || 'signup' };\r\n+    \r\n+    if (userType === 'Corporate' && email) {\r\n+      query.email = email;\r\n+    } else if (phone) {\r\n+      query.phone = phone;\r\n+    } else {\r\n+      return res.status(400).json({ \r\n+        success: false, \r\n+        message: 'Invalid verification parameters' \r\n+      });\r\n     }\r\n \r\n-    try {\r\n-      // Build query based on userType\r\n-      let query = { otp, purpose };\r\n-      \r\n-      if (userType === 'Corporate' && email) {\r\n-        query.email = email;\r\n-      } else if (phone) {\r\n-        query.phone = phone;\r\n-      } else {\r\n-        return res.status(400).json({ success: false, error: 'Invalid verification parameters' });\r\n-      }\r\n+    const otpRecord = await OTP.findOne(query);\r\n \r\n-      const existingOtp = await OTP.findOne(query);\r\n+    if (!otpRecord) {\r\n+      return res.status(400).json({ \r\n+        success: false, \r\n+        message: 'Invalid or expired OTP' \r\n+      });\r\n+    }\r\n \r\n-      if (!existingOtp) {\r\n-        return res.status(400).json({ success: false, error: 'Invalid or expired OTP' });\r\n-      }\r\n+    // OTP is valid\r\n+    console.log(`✅ OTP verified for ${email || phone} with purpose: ${purpose || 'signup'}`);\r\n \r\n-      console.log(`✅ OTP verified for ${email || phone} with purpose: ${purpose}`);\r\n+    // Don't delete OTP here as it might be needed by the registration process\r\n+    // It will be deleted after successful registration\r\n \r\n-      // Delete OTP after successful verification\r\n-      if (email) {\r\n-        await OTP.deleteMany({ email, purpose });\r\n-      }\r\n-      if (phone) {\r\n-        await OTP.deleteMany({ phone, purpose });\r\n-      }\r\n+    res.json({\r\n+      success: true,\r\n+      message: 'OTP verified successfully'\r\n+    });\r\n \r\n-      return res.status(200).json({ success: true, message: 'OTP verified successfully' });\r\n-    } catch (error) {\r\n-      console.error('❌ Error verifying OTP:', error.message);\r\n-      return res.status(500).json({ success: false, error: 'Failed to verify OTP' });\r\n-    }\r\n-  } catch (decryptionError) {\r\n-    console.error('OTP verification decryption error:', decryptionError);\r\n-    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n+  } catch (error) {\r\n+    console.error('❌ Verify OTP error:', error);\r\n+    res.status(500).json({ \r\n+      success: false, \r\n+      message: error.message \r\n+    });\r\n   }\r\n };\r\n \r\n"
                },
                {
                    "date": 1753634453787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,86 +115,8 @@\n     res.status(500).json({ message: error.message });\r\n   }\r\n };\r\n \r\n-    // Validate based on userType\r\n-    if (userType === 'Corporate') {\r\n-      if (!email) {\r\n-        return res.status(400).json({ success: false, error: 'Email is required for Corporate users' });\r\n-      }\r\n-    } else {\r\n-      if (!phone) {\r\n-        return res.status(400).json({ success: false, error: 'Phone is required for Individual users' });\r\n-      }\r\n-    }\r\n-\r\n-    try {\r\n-      // Check if user already exists when purpose is \"signup\"\r\n-      if (purpose === 'signup') {\r\n-        let existingUser;\r\n-        if (userType === 'Corporate' && email) {\r\n-          existingUser = await User.findOne({ email });\r\n-        } else if (phone) {\r\n-          existingUser = await User.findOne({ phone });\r\n-        }\r\n-        \r\n-        if (existingUser) {\r\n-          return res.status(409).json({ success: false, error: 'User already exists' });\r\n-        }\r\n-      }\r\n-\r\n-      const otp = generateOTP();\r\n-      console.log(`📲 Generating OTP for ${email || phone} with purpose: ${purpose}`);\r\n-\r\n-      // Create OTP record\r\n-      const otpData = {\r\n-        otp,\r\n-        purpose,\r\n-        userType: userType || 'Individual'\r\n-      };\r\n-\r\n-      if (email) {\r\n-        otpData.email = email;\r\n-      }\r\n-      if (phone) {\r\n-        otpData.phone = phone;\r\n-      }\r\n-\r\n-      // Clear existing OTPs\r\n-      if (email) {\r\n-        await OTP.deleteMany({ email, purpose });\r\n-      }\r\n-      if (phone) {\r\n-        await OTP.deleteMany({ phone, purpose });\r\n-      }\r\n-\r\n-      // Save new OTP\r\n-      await OTP.create(otpData);\r\n-\r\n-      // Send OTP via appropriate channel\r\n-      if (userType === 'Corporate' && email) {\r\n-        console.log(`📧 OTP for ${email}: ${otp}`);\r\n-        await sendOTPEmail(email, otp, purpose);\r\n-      } else if (phone) {\r\n-        console.log(`📲 OTP for ${phone}: ${otp}`);\r\n-        // SMS sending logic would go here\r\n-      }\r\n-\r\n-      const message = userType === 'Corporate' ? \r\n-        'OTP sent to your email address' : \r\n-        'OTP sent to your phone number';\r\n-\r\n-      return res.status(200).json({ success: true, message });\r\n-    } catch (error) {\r\n-      console.error('❌ Error sending OTP:', error.message);\r\n-      return res.status(500).json({ success: false, error: 'Failed to send OTP' });\r\n-    }\r\n-  } catch (decryptionError) {\r\n-    console.error('OTP send decryption error:', decryptionError);\r\n-    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n-  }\r\n-};\r\n-\r\n exports.verifyOtp = async (req, res) => {\r\n   try {\r\n     console.log('🔍 Verifying OTP...');\r\n     console.log('🔓 Decrypting OTP verification data...');\r\n"
                }
            ],
            "date": 1752836234244,
            "name": "Commit-0",
            "content": "const OTP = require('../models/OTP');\r\nconst User = require('../models/User'); // ✅ ADD THIS\r\nconst { encryptData, decryptData } = require('../utils/cryptoUtil');\r\n\r\nconst generateOTP = () => {\r\n  return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP\r\n};\r\n\r\nexports.sendOtp = async (req, res) => {\r\n  try {\r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('🔓 Decrypting OTP send data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const { phone, purpose } = decryptedData;\r\n    console.log('📲 OTP send request for phone:', phone, 'purpose:', purpose);\r\n\r\n    if (!phone || !purpose) {\r\n      return res.status(400).json({ success: false, error: 'Phone and purpose are required' });\r\n    }\r\n\r\n    try {\r\n      // ✅ Check if user already exists when purpose is \"signup\"\r\n      if (purpose === 'signup') {\r\n        const existingUser = await User.findOne({ phone });\r\n        if (existingUser) {\r\n          return res.status(409).json({ success: false, error: 'User already exists' });\r\n        }\r\n      }\r\n\r\n      const otp = generateOTP();\r\n      console.log(`📲 Generating OTP for ${phone} with purpose: ${purpose}`);\r\n\r\n      await OTP.create({ phone, otp, purpose });\r\n\r\n      console.log(`📲 OTP for ${phone}: ${otp}`);\r\n\r\n      return res.status(200).json({ success: true, message: 'OTP sent successfully' });\r\n    } catch (error) {\r\n      console.error('❌ Error sending OTP:', error.message);\r\n      return res.status(500).json({ success: false, error: 'Failed to send OTP' });\r\n    }\r\n  } catch (decryptionError) {\r\n    console.error('OTP send decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\nexports.verifyOtp = async (req, res) => {\r\n  try {\r\n    console.log('🔍 Verifying OTP...');\r\n    \r\n    // Decrypt the incoming data\r\n    let decryptedData;\r\n    if (req.body.encryptedData) {\r\n      console.log('🔓 Decrypting OTP verification data...');\r\n      decryptedData = decryptData(req.body.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = req.body;\r\n    }\r\n\r\n    const { phone, otp, purpose } = decryptedData;\r\n    console.log('✅ OTP verification for phone:', phone, 'purpose:', purpose);\r\n\r\n    if (!phone || !otp || !purpose) {\r\n      return res.status(400).json({ success: false, error: 'Phone, OTP, and purpose are required' });\r\n    }\r\n\r\n    try {\r\n      const existingOtp = await OTP.findOne({ phone, otp, purpose });\r\n\r\n      if (!existingOtp) {\r\n        return res.status(400).json({ success: false, error: 'Invalid or expired OTP' });\r\n      }\r\n\r\n      console.log(`✅ OTP verified for ${phone} with purpose: ${purpose}`);\r\n\r\n      // ✅ Just verify, don't create user\r\n      await OTP.deleteMany({ phone, purpose }); // optional: cleanup OTPs\r\n\r\n      return res.status(200).json({ success: true, message: 'OTP verified successfully' });\r\n    } catch (error) {\r\n      console.error('❌ Error verifying OTP:', error.message);\r\n      return res.status(500).json({ success: false, error: 'Failed to verify OTP' });\r\n    }\r\n  } catch (decryptionError) {\r\n    console.error('OTP verification decryption error:', decryptionError);\r\n    return res.status(400).json({ success: false, error: 'Invalid encrypted data' });\r\n  }\r\n};\r\n\r\n"
        }
    ]
}