{
    "sourceFile": "backend/src/services/AuthService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1753608750427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753614088473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,11 +175,11 @@\n     }\r\n \r\n     const { phone, email, password, userType } = decryptedData;\r\n     console.log('üì± [AuthService] Extracted phone:', phone);\r\n-    console.log('ÔøΩ [AuthService] Extracted email:', email);\r\n+    console.log('\udce7 [AuthService] Extracted email:', email);\r\n     console.log('üë§ [AuthService] Extracted userType:', userType);\r\n-    console.log('ÔøΩüîë [AuthService] Password length:', password?.length || 0);\r\n+    console.log('\ud83düîë [AuthService] Password length:', password?.length || 0);\r\n \r\n     if ((!phone && !email) || !password) {\r\n       console.log('‚ùå [AuthService] Missing login credentials');\r\n       throw new Error('Phone/Email and password are required');\r\n"
                }
            ],
            "date": 1753608750427,
            "name": "Commit-0",
            "content": "const User = require('../models/User');\r\nconst OTP = require('../models/OTP');\r\nconst bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken');\r\nconst crypto = require('crypto');\r\nconst sendEmail = require('../utils/sendEmail');\r\nconst { encryptData, decryptData } = require('../utils/cryptoUtil');\r\n\r\n/**\r\n * Centralized Authentication Service\r\n * This service contains all authentication logic extracted from authController\r\n * while preserving the exact same functionality and behavior\r\n */\r\nclass AuthService {\r\n  \r\n  /**\r\n   * User Registration Service\r\n   * Handles individual, corporate, and admin user registration\r\n   */\r\n  async register(requestData) {\r\n    console.log('üîÑ [AuthService] Processing registration via centralized service');\r\n    \r\n    // Decrypt the incoming data (preserving existing encryption logic)\r\n    let decryptedData;\r\n    if (requestData.encryptedData) {\r\n      console.log('üîì [AuthService] Decrypting signup data...');\r\n      decryptedData = decryptData(requestData.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = requestData;\r\n    }\r\n\r\n    const {\r\n      name,\r\n      email,\r\n      phone,\r\n      password,\r\n      confirmPassword,\r\n      otp,\r\n      userType,\r\n      companyDetails,\r\n      role,\r\n      gender,\r\n      dob,\r\n      pincode\r\n    } = decryptedData;\r\n\r\n    console.log('üìù [AuthService] Signup attempt for phone:', phone);\r\n\r\n    // 1. Basic required fields validation (preserving exact validation)\r\n    if (\r\n      !name ||\r\n      !phone ||\r\n      !password ||\r\n      !confirmPassword ||\r\n      !otp ||\r\n      !userType ||\r\n      !gender ||\r\n      !dob ||\r\n      !pincode\r\n    ) {\r\n      throw new Error('Missing required fields');\r\n    }\r\n\r\n    // 2. Password match check\r\n    if (password !== confirmPassword) {\r\n      throw new Error('Password and Confirm Password do not match');\r\n    }\r\n\r\n    // 3. Corporate user validation\r\n    if (userType === 'corporate') {\r\n      if (\r\n        !companyDetails ||\r\n        !companyDetails.companyName ||\r\n        !companyDetails.gstNumber ||\r\n        !companyDetails.address\r\n      ) {\r\n        throw new Error('Corporate details are required');\r\n      }\r\n    }\r\n\r\n    // 4. Check if user already exists\r\n    const existingUser = await User.findOne({ phone });\r\n    if (existingUser) {\r\n      throw new Error('User already exists');\r\n    }\r\n\r\n    // 5. Admin role restriction (preserving exact validation)\r\n    if ((role === 'admin' || role === 'tempAdmin') && (!email || !email.endsWith('@zyftoo.com'))) {\r\n      const error = new Error('Only @zyftoo.com emails allowed for admin roles');\r\n      error.statusCode = 403;\r\n      throw error;\r\n    }\r\n\r\n    // 6. Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // 7. Email verification token\r\n    const emailVerificationToken = crypto.randomBytes(20).toString('hex');\r\n\r\n    // 8. Prepare user data (preserving exact structure)\r\n    const newUser = new User({\r\n      name,\r\n      email,\r\n      phone,\r\n      password: hashedPassword,\r\n      userType,\r\n      role: role || 'user',\r\n      gender,\r\n      dob,\r\n      pincode,\r\n      companyDetails: userType === 'corporate' ? {\r\n        companyName: companyDetails.companyName,\r\n        gstNumber: companyDetails.gstNumber,\r\n        address: companyDetails.address\r\n      } : undefined,\r\n      isEmailVerified: false,\r\n      emailVerificationToken\r\n    });\r\n\r\n    await newUser.save();\r\n\r\n    // 9. Send verification email (preserving exact email logic)\r\n    const verificationUrl = `http://localhost:5000/api/auth/verify-email/${emailVerificationToken}`;\r\n    console.log(`üîó [AuthService] Email verification URL: ${verificationUrl}`);\r\n\r\n    const html = `\r\n      <p>Hi ${newUser.name},</p>\r\n      <p>Please verify your email by clicking the link below:</p>\r\n      <a href=\"${verificationUrl}\">${verificationUrl}</a>\r\n    `;\r\n\r\n    await sendEmail({\r\n      to: newUser.email,\r\n      subject: 'Verify your email for Zyftoo',\r\n      html,\r\n    });\r\n\r\n    // 10. Remove OTP (preserving exact cleanup logic)\r\n    await OTP.deleteMany({ phone, purpose: 'signup' });\r\n\r\n    console.log('‚úÖ [AuthService] Registration completed successfully');\r\n\r\n    return {\r\n      success: true,\r\n      message: 'User registered successfully. Verification email sent.',\r\n      emailVerificationToken // for dev testing\r\n    };\r\n  }\r\n\r\n  /**\r\n   * User Login Service\r\n   * Handles authentication for all user types\r\n   */\r\n  async login(requestData) {\r\n    console.log('üîÑ [AuthService] Processing login via centralized service');\r\n    console.log('üì¶ [AuthService] Raw request data keys:', Object.keys(requestData));\r\n    \r\n    // Decrypt the incoming data (preserving existing decryption logic)\r\n    let decryptedData;\r\n    if (requestData.encryptedData) {\r\n      console.log('üîì [AuthService] Attempting to decrypt login data...');\r\n      console.log('üìù [AuthService] Encrypted data received:', requestData.encryptedData);\r\n      \r\n      try {\r\n        decryptedData = decryptData(requestData.encryptedData);\r\n        console.log('‚úÖ [AuthService] Decryption successful:', decryptedData);\r\n      } catch (decryptError) {\r\n        console.error('‚ùå [AuthService] Decryption failed:', decryptError.message);\r\n        throw decryptError;\r\n      }\r\n    } else {\r\n      console.log('‚ö†Ô∏è [AuthService] No encrypted data found, using fallback...');\r\n      decryptedData = requestData;\r\n    }\r\n\r\n    const { phone, password } = decryptedData;\r\n    console.log('üì± [AuthService] Extracted phone:', phone);\r\n    console.log('üîë [AuthService] Password length:', password?.length || 0);\r\n\r\n    if (!phone || !password) {\r\n      console.log('‚ùå [AuthService] Missing phone or password');\r\n      throw new Error('Phone and password are required');\r\n    }\r\n\r\n    console.log('üîç [AuthService] Looking up user with phone:', phone);\r\n    const user = await User.findOne({ phone });\r\n    \r\n    if (!user) {\r\n      console.log('‚ùå [AuthService] User not found for phone:', phone);\r\n      const error = new Error('User not found');\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    console.log('‚úÖ [AuthService] User found:', user.name);\r\n    console.log('üîê [AuthService] Comparing passwords...');\r\n    \r\n    const isMatch = await bcrypt.compare(password, user.password);\r\n    if (!isMatch) {\r\n      console.log('‚ùå [AuthService] Password does not match');\r\n      const error = new Error('Invalid password');\r\n      error.statusCode = 401;\r\n      throw error;\r\n    }\r\n\r\n    console.log('‚úÖ [AuthService] Password matches, generating token...');\r\n    \r\n    // Generate JWT token (preserving exact token structure)\r\n    const token = jwt.sign(\r\n      { id: user._id, role: user.role },\r\n      process.env.JWT_SECRET,\r\n      { expiresIn: process.env.JWT_EXPIRE }\r\n    );\r\n\r\n    console.log('‚úÖ [AuthService] Token generated successfully');\r\n\r\n    // Return user data (preserving exact response structure)\r\n    return {\r\n      token,\r\n      user: {\r\n        id: user._id,\r\n        name: user.name,\r\n        email: user.email,\r\n        phone: user.phone,\r\n        userType: user.userType,\r\n        role: user.role,\r\n        isEmailVerified: user.isEmailVerified\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Password Reset Service\r\n   */\r\n  async resetPassword(requestData) {\r\n    console.log('üîÑ [AuthService] Processing password reset via centralized service');\r\n    \r\n    // Decrypt the incoming data (preserving existing decryption logic)\r\n    let decryptedData;\r\n    if (requestData.encryptedData) {\r\n      console.log('üîì [AuthService] Decrypting password reset data...');\r\n      decryptedData = decryptData(requestData.encryptedData);\r\n    } else {\r\n      // Fallback to unencrypted data for backward compatibility\r\n      decryptedData = requestData;\r\n    }\r\n\r\n    const { phone, newPassword } = decryptedData;\r\n    console.log('üîÑ [AuthService] Password reset attempt for phone:', phone);\r\n\r\n    if (!phone || !newPassword) {\r\n      throw new Error('Phone and new password are required.');\r\n    }\r\n\r\n    // Step 1: Find user by phone\r\n    const user = await User.findOne({ phone });\r\n    if (!user) {\r\n      const error = new Error('User not found.');\r\n      error.statusCode = 404;\r\n      throw error;\r\n    }\r\n\r\n    // Step 2: Hash new password\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    // Step 3: Update password only\r\n    user.password = hashedPassword;\r\n    await user.save();\r\n\r\n    // Step 4: Clear OTPs related to password reset (optional but safe)\r\n    await OTP.deleteMany({ phone, purpose: 'reset' });\r\n\r\n    console.log('‚úÖ [AuthService] Password reset completed successfully');\r\n\r\n    // Step 5: Return success response\r\n    return {\r\n      success: true,\r\n      message: 'Password updated successfully.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Email Verification Service\r\n   */\r\n  async verifyEmail(token) {\r\n    console.log('üîÑ [AuthService] Processing email verification via centralized service');\r\n    console.log('üìß [AuthService] Verification token:', token);\r\n\r\n    const user = await User.findOne({ emailVerificationToken: token });\r\n\r\n    if (!user) {\r\n      throw new Error('Invalid or expired token');\r\n    }\r\n\r\n    user.emailVerified = true;\r\n    user.emailVerificationToken = undefined;\r\n\r\n    await user.save();\r\n\r\n    const updatedUser = await User.findById(user._id); // confirm save\r\n    console.log('‚úÖ [AuthService] Email verified. Current DB state:', updatedUser.emailVerified);\r\n\r\n    return {\r\n      message: 'Email verified successfully'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check User Existence Service\r\n   */\r\n  async checkUserExists(phone) {\r\n    console.log('üîÑ [AuthService] Checking user existence for phone:', phone);\r\n    \r\n    const user = await User.findOne({ phone });\r\n    const exists = !!user;\r\n    \r\n    console.log('üîç [AuthService] User exists:', exists);\r\n    \r\n    return {\r\n      exists\r\n    };\r\n  }\r\n}\r\n\r\n// Export single instance (Singleton pattern)\r\nmodule.exports = new AuthService();\r\n"
        }
    ]
}