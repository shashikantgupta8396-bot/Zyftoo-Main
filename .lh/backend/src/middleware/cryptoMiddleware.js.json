{
    "sourceFile": "backend/src/middleware/cryptoMiddleware.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752831493449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752831493449,
            "name": "Commit-0",
            "content": "const { decrypt, createEncryptedResponse, isValidEncryptedData } = require('../utils/cryptoUtil');\r\n\r\n/**\r\n * Middleware to decrypt incoming encrypted requests and encrypt outgoing responses\r\n */\r\nconst cryptoMiddleware = (req, res, next) => {\r\n  // Store original res.json method\r\n  const originalJson = res.json;\r\n  \r\n  // Override res.json to encrypt response\r\n  res.json = function(data) {\r\n    try {\r\n      // Only encrypt successful responses with actual data\r\n      if (data && (data.success !== false)) {\r\n        const encryptedResponse = createEncryptedResponse(data);\r\n        return originalJson.call(this, encryptedResponse);\r\n      } else {\r\n        // For error responses, send as-is for debugging (can be encrypted too if needed)\r\n        return originalJson.call(this, data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Response encryption error:', error);\r\n      return originalJson.call(this, {\r\n        success: false,\r\n        message: 'Failed to encrypt response',\r\n        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'\r\n      });\r\n    }\r\n  };\r\n\r\n  // Check if request has encrypted body\r\n  if (req.body && req.body.body && typeof req.body.body === 'string') {\r\n    try {\r\n      // Validate if the body appears to be encrypted\r\n      if (!isValidEncryptedData(req.body.body)) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          message: 'Invalid encrypted data format'\r\n        });\r\n      }\r\n\r\n      // Decrypt the request body\r\n      const decryptedData = decrypt(req.body.body);\r\n      \r\n      // Store decrypted data in req.decryptedBody\r\n      req.decryptedBody = decryptedData;\r\n      \r\n      // Keep original body for logging/debugging if needed\r\n      req.originalEncryptedBody = req.body.body;\r\n      \r\n      console.log('Request decrypted successfully for:', req.path);\r\n      \r\n    } catch (error) {\r\n      console.error('Request decryption error:', error);\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Failed to decrypt request data',\r\n        error: process.env.NODE_ENV === 'development' ? error.message : 'Invalid request format'\r\n      });\r\n    }\r\n  } else {\r\n    // For non-encrypted requests, use original body\r\n    req.decryptedBody = req.body;\r\n  }\r\n\r\n  next();\r\n};\r\n\r\n/**\r\n * Middleware specifically for encrypted-only endpoints\r\n * This will reject any non-encrypted requests\r\n */\r\nconst requireEncryption = (req, res, next) => {\r\n  if (!req.body || !req.body.body || typeof req.body.body !== 'string') {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: 'This endpoint requires encrypted data'\r\n    });\r\n  }\r\n\r\n  if (!isValidEncryptedData(req.body.body)) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: 'Invalid encrypted data format'\r\n    });\r\n  }\r\n\r\n  next();\r\n};\r\n\r\n/**\r\n * Middleware for endpoints that can handle both encrypted and non-encrypted requests\r\n */\r\nconst optionalEncryption = (req, res, next) => {\r\n  // This middleware allows both encrypted and non-encrypted requests\r\n  // The cryptoMiddleware will handle decryption if data is encrypted\r\n  next();\r\n};\r\n\r\nmodule.exports = {\r\n  cryptoMiddleware,\r\n  requireEncryption,\r\n  optionalEncryption\r\n};\r\n"
        }
    ]
}