{
    "sourceFile": "Ninico/util/analyticsService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753711237033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753711237033,
            "name": "Commit-0",
            "content": "import { apiService } from './apiService';\r\n\r\n/**\r\n * Analytics service for tracking product interactions\r\n */\r\nclass AnalyticsService {\r\n  constructor() {\r\n    this.baseUrl = '/analytics';\r\n    this.trackingQueue = [];\r\n    this.isProcessing = false;\r\n  }\r\n\r\n  /**\r\n   * Track a product view with optional debouncing\r\n   * @param {string} productId - The product ID to track\r\n   * @param {object} options - Tracking options\r\n   */\r\n  async trackProductView(productId, options = {}) {\r\n    try {\r\n      const {\r\n        userType = 'individual',\r\n        source = 'web',\r\n        immediate = false,\r\n        debounceMs = 1000\r\n      } = options;\r\n\r\n      const trackingData = {\r\n        productId,\r\n        userType,\r\n        source,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      if (immediate) {\r\n        return await this._sendTrackingRequest(trackingData);\r\n      }\r\n\r\n      // Add to queue with debouncing\r\n      this._addToQueue(trackingData, debounceMs);\r\n      \r\n    } catch (error) {\r\n      console.error('Error tracking product view:', error);\r\n      // Don't throw error to avoid breaking user experience\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add tracking data to queue with debouncing\r\n   * @private\r\n   */\r\n  _addToQueue(trackingData, debounceMs) {\r\n    // Remove existing entry for the same product (debounce)\r\n    this.trackingQueue = this.trackingQueue.filter(\r\n      item => item.productId !== trackingData.productId\r\n    );\r\n    \r\n    // Add new entry\r\n    this.trackingQueue.push(trackingData);\r\n    \r\n    // Process queue after debounce delay\r\n    setTimeout(() => {\r\n      this._processQueue();\r\n    }, debounceMs);\r\n  }\r\n\r\n  /**\r\n   * Process the tracking queue\r\n   * @private\r\n   */\r\n  async _processQueue() {\r\n    if (this.isProcessing || this.trackingQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.isProcessing = true;\r\n    const itemsToProcess = [...this.trackingQueue];\r\n    this.trackingQueue = [];\r\n\r\n    try {\r\n      // Process items in parallel (with reasonable batch size)\r\n      const batchSize = 5;\r\n      for (let i = 0; i < itemsToProcess.length; i += batchSize) {\r\n        const batch = itemsToProcess.slice(i, i + batchSize);\r\n        await Promise.allSettled(\r\n          batch.map(item => this._sendTrackingRequest(item))\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('Error processing tracking queue:', error);\r\n    } finally {\r\n      this.isProcessing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send tracking request to backend\r\n   * @private\r\n   */\r\n  async _sendTrackingRequest(trackingData) {\r\n    const { productId, ...requestData } = trackingData;\r\n    \r\n    return await apiService.post(\r\n      `${this.baseUrl}/products/${productId}/view`,\r\n      requestData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get popular products\r\n   * @param {object} filters - Filter options\r\n   */\r\n  async getPopularProducts(filters = {}) {\r\n    try {\r\n      const {\r\n        limit = 10,\r\n        userType = 'all',\r\n        category,\r\n        timeFrame = 'all'\r\n      } = filters;\r\n\r\n      const params = new URLSearchParams();\r\n      params.append('limit', limit.toString());\r\n      params.append('userType', userType);\r\n      params.append('timeFrame', timeFrame);\r\n      \r\n      if (category) {\r\n        params.append('category', category);\r\n      }\r\n\r\n      const response = await apiService.get(\r\n        `${this.baseUrl}/products/popular?${params.toString()}`\r\n      );\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error fetching popular products:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get analytics for a specific product (admin only)\r\n   * @param {string} productId - The product ID\r\n   */\r\n  async getProductAnalytics(productId) {\r\n    try {\r\n      const response = await apiService.get(\r\n        `${this.baseUrl}/products/${productId}`\r\n      );\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error fetching product analytics:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get analytics dashboard data (admin only)\r\n   */\r\n  async getAnalyticsDashboard() {\r\n    try {\r\n      const response = await apiService.get(\r\n        `${this.baseUrl}/dashboard`\r\n      );\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error fetching analytics dashboard:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track product view from product card click\r\n   * @param {object} product - Product object\r\n   * @param {object} context - Context information\r\n   */\r\n  trackProductCardClick(product, context = {}) {\r\n    const {\r\n      userType = 'individual',\r\n      listType = 'general', // general, search, category, popular, recommended\r\n      position,\r\n      source = 'product-card'\r\n    } = context;\r\n\r\n    const trackingSource = `${source}-${listType}${position ? `-pos${position}` : ''}`;\r\n    \r\n    this.trackProductView(product._id, {\r\n      userType,\r\n      source: trackingSource,\r\n      debounceMs: 500 // Shorter debounce for clicks\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Track product view from product details page\r\n   * @param {string} productId - Product ID\r\n   * @param {object} context - Context information\r\n   */\r\n  trackProductPageView(productId, context = {}) {\r\n    const {\r\n      userType = 'individual',\r\n      referrer = 'direct',\r\n      source = 'product-page'\r\n    } = context;\r\n\r\n    const trackingSource = `${source}-${referrer}`;\r\n    \r\n    this.trackProductView(productId, {\r\n      userType,\r\n      source: trackingSource,\r\n      immediate: true // Product page views are tracked immediately\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Utility to determine user type from auth context\r\n   * @param {object} user - User object from auth context\r\n   */\r\n  getUserType(user) {\r\n    if (!user) return 'guest';\r\n    \r\n    // Check if user has corporate features\r\n    if (user.userType === 'corporate' || \r\n        user.corporateDetails || \r\n        user.role === 'corporate') {\r\n      return 'corporate';\r\n    }\r\n    \r\n    return 'individual';\r\n  }\r\n\r\n  /**\r\n   * Create tracking-enabled product card props\r\n   * @param {object} product - Product object\r\n   * @param {object} context - Context information\r\n   */\r\n  createTrackingProps(product, context = {}) {\r\n    return {\r\n      onClick: () => this.trackProductCardClick(product, context),\r\n      onMouseEnter: () => {\r\n        // Optional: Track hover/preview events\r\n        if (context.trackHover) {\r\n          this.trackProductView(product._id, {\r\n            ...context,\r\n            source: 'product-hover',\r\n            debounceMs: 2000\r\n          });\r\n        }\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst analyticsService = new AnalyticsService();\r\n\r\nexport { analyticsService };\r\nexport default analyticsService;\r\n"
        }
    ]
}