{
    "sourceFile": "Ninico/util/apiExamples.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752832805257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752832805257,
            "name": "Commit-0",
            "content": "/**\r\n * API Service Usage Examples\r\n * This file demonstrates how to use the new encrypted API service\r\n * alongside existing fetch calls for backward compatibility\r\n */\r\n\r\nimport { post, get, put, del } from './apiService';\r\nimport { AUTH, USER, PRODUCT, buildUrl, withId } from './apiEndpoints';\r\n\r\n// ============================================================================\r\n// EXAMPLE 1: Migration from fetch to encrypted API service\r\n// ============================================================================\r\n\r\n// OLD WAY (still works, not encrypted)\r\nexport const loginWithFetch = async (phone: string, password: string) => {\r\n  const response = await fetch('http://localhost:5000/api/auth/login', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({ phone, password }),\r\n  });\r\n  return response.json();\r\n};\r\n\r\n// NEW WAY (encrypted, secure)\r\nexport const loginWithEncryption = async (phone: string, password: string) => {\r\n  const response = await post(AUTH.LOGIN, { phone, password }, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// NEW WAY (unencrypted but with better error handling)\r\nexport const loginWithApiService = async (phone: string, password: string) => {\r\n  const response = await post(AUTH.LOGIN, { phone, password }, false); // encrypt=false\r\n  return response.data;\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 2: User Management Examples\r\n// ============================================================================\r\n\r\n// Get user profile (with decryption if server sends encrypted data)\r\nexport const getUserProfile = async (userId: string) => {\r\n  const response = await get(withId(USER.PROFILE, userId), undefined, true); // decrypt=true\r\n  return response.data;\r\n};\r\n\r\n// Update user profile (with encryption)\r\nexport const updateUserProfile = async (userId: string, profileData: any) => {\r\n  const response = await put(withId(USER.UPDATE_PROFILE, userId), profileData, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 3: Product Management Examples\r\n// ============================================================================\r\n\r\n// Get all products (no encryption needed for public data)\r\nexport const getAllProducts = async (filters?: Record<string, any>) => {\r\n  const response = await get(PRODUCT.GET_ALL, filters, false); // decrypt=false\r\n  return response.data;\r\n};\r\n\r\n// Create product (admin only, with encryption)\r\nexport const createProduct = async (productData: any) => {\r\n  const response = await post(PRODUCT.CREATE, productData, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 4: Authentication Examples\r\n// ============================================================================\r\n\r\n// Sign up with encrypted sensitive data\r\nexport const signUp = async (userData: any) => {\r\n  const response = await post(AUTH.SIGNUP, userData, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// Check if user exists (no encryption needed)\r\nexport const checkUserExists = async (phone: string) => {\r\n  const response = await get(`${AUTH.CHECK_USER}/${phone}`, undefined, false);\r\n  return response.data;\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 5: OTP Examples\r\n// ============================================================================\r\n\r\nimport { OTP } from './apiEndpoints';\r\n\r\n// Send OTP (encrypt phone number for privacy)\r\nexport const sendOTP = async (phone: string, purpose: string) => {\r\n  const response = await post(OTP.SEND, { phone, purpose }, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// Verify OTP (encrypt sensitive data)\r\nexport const verifyOTP = async (phone: string, otp: string, purpose: string) => {\r\n  const response = await post(OTP.VERIFY, { phone, otp, purpose }, true); // encrypt=true\r\n  return response.data;\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 6: Mixed Usage - Gradual Migration\r\n// ============================================================================\r\n\r\n// You can mix old fetch calls with new API service calls\r\nexport const mixedExample = async () => {\r\n  // Old fetch call (still works)\r\n  const oldResponse = await fetch('http://localhost:5000/api/products');\r\n  const products = await oldResponse.json();\r\n\r\n  // New API service call (with better error handling)\r\n  const userResponse = await get(USER.PROFILE, undefined, false);\r\n  const user = userResponse.data;\r\n\r\n  return { products, user };\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 7: Error Handling\r\n// ============================================================================\r\n\r\nexport const exampleWithErrorHandling = async () => {\r\n  try {\r\n    const response = await post(AUTH.LOGIN, { phone: '1234567890', password: 'test' }, true);\r\n    \r\n    if (response.success) {\r\n      console.log('Login successful:', response.data);\r\n      return response.data;\r\n    } else {\r\n      console.error('Login failed:', response.message);\r\n      throw new Error(response.message);\r\n    }\r\n  } catch (error: any) {\r\n    console.error('API call failed:', error.message);\r\n    // Handle error appropriately\r\n    throw error;\r\n  }\r\n};\r\n\r\n// ============================================================================\r\n// EXAMPLE 8: Using buildUrl helper\r\n// ============================================================================\r\n\r\nexport const searchProducts = async (query: string, category?: string) => {\r\n  const searchUrl = buildUrl(PRODUCT.SEARCH, { \r\n    q: query, \r\n    category: category || '' \r\n  });\r\n  \r\n  // You can use with fetch (old way)\r\n  const fetchResponse = await fetch(searchUrl);\r\n  \r\n  // Or with new API service\r\n  const apiResponse = await get(PRODUCT.SEARCH, { q: query, category });\r\n  \r\n  return apiResponse.data;\r\n};\r\n"
        }
    ]
}