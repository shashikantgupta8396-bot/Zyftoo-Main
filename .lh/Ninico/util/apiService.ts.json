{
    "sourceFile": "Ninico/util/apiService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752832805357,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752832805357,
            "name": "Commit-0",
            "content": "/**\r\n * Encrypted API Service\r\n * Provides secure API communication with optional encryption/decryption\r\n */\r\n\r\nimport axios, { AxiosResponse, AxiosRequestConfig } from 'axios';\r\nimport CryptoJS from 'crypto-js';\r\nimport { API_BASE_URL } from './apiEndpoints';\r\n\r\n// Encryption configuration\r\nconst ENCRYPTION_KEY = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || 'default-32-character-secret-key';\r\nconst ENCRYPTION_IV = process.env.NEXT_PUBLIC_ENCRYPTION_IV || 'default-16-chars';\r\n\r\n// Create axios instance with default configuration\r\nconst apiClient = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 10000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n// Request interceptor to add auth token\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    // Add auth token if available\r\n    if (typeof window !== 'undefined') {\r\n      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n      if (token) {\r\n        config.headers.Authorization = `Bearer ${token}`;\r\n      }\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor for error handling\r\napiClient.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    // Handle common errors\r\n    if (error.response?.status === 401) {\r\n      // Clear invalid tokens\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.removeItem('authToken');\r\n        sessionStorage.removeItem('authToken');\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n/**\r\n * Encrypt data using AES encryption\r\n */\r\nexport const encryptData = (data: any): string => {\r\n  try {\r\n    const jsonString = JSON.stringify(data);\r\n    const encrypted = CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY, {\r\n      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    return encrypted.toString();\r\n  } catch (error) {\r\n    console.error('Encryption error:', error);\r\n    throw new Error('Failed to encrypt data');\r\n  }\r\n};\r\n\r\n/**\r\n * Decrypt data using AES decryption\r\n */\r\nexport const decryptData = (encryptedData: string): any => {\r\n  try {\r\n    const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY, {\r\n      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\r\n    return JSON.parse(decryptedString);\r\n  } catch (error) {\r\n    console.error('Decryption error:', error);\r\n    throw new Error('Failed to decrypt data');\r\n  }\r\n};\r\n\r\n/**\r\n * Enhanced API Service Interface\r\n */\r\ninterface ApiResponse<T = any> {\r\n  data: T;\r\n  message?: string;\r\n  success: boolean;\r\n  status: number;\r\n}\r\n\r\ninterface ApiServiceConfig extends AxiosRequestConfig {\r\n  encrypt?: boolean;\r\n  decrypt?: boolean;\r\n}\r\n\r\n/**\r\n * POST request with optional encryption\r\n */\r\nexport const post = async <T = any>(\r\n  endpoint: string,\r\n  payload: any = {},\r\n  encrypt: boolean = false,\r\n  config?: AxiosRequestConfig\r\n): Promise<ApiResponse<T>> => {\r\n  try {\r\n    let requestData = payload;\r\n    \r\n    // Encrypt payload if requested\r\n    if (encrypt && payload) {\r\n      requestData = {\r\n        encryptedData: encryptData(payload)\r\n      };\r\n    }\r\n\r\n    const response: AxiosResponse = await apiClient.post(endpoint, requestData, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        // If decryption fails, keep original data\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error: any) {\r\n    console.error('POST request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * GET request with optional decryption\r\n */\r\nexport const get = async <T = any>(\r\n  endpoint: string,\r\n  params?: Record<string, any>,\r\n  decrypt: boolean = false,\r\n  config?: AxiosRequestConfig\r\n): Promise<ApiResponse<T>> => {\r\n  try {\r\n    const response: AxiosResponse = await apiClient.get(endpoint, {\r\n      ...config,\r\n      params\r\n    });\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if requested and it exists\r\n    if (decrypt && responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        // If decryption fails, keep original data\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error: any) {\r\n    console.error('GET request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * PUT request with optional encryption\r\n */\r\nexport const put = async <T = any>(\r\n  endpoint: string,\r\n  payload: any = {},\r\n  encrypt: boolean = false,\r\n  config?: AxiosRequestConfig\r\n): Promise<ApiResponse<T>> => {\r\n  try {\r\n    let requestData = payload;\r\n    \r\n    // Encrypt payload if requested\r\n    if (encrypt && payload) {\r\n      requestData = {\r\n        encryptedData: encryptData(payload)\r\n      };\r\n    }\r\n\r\n    const response: AxiosResponse = await apiClient.put(endpoint, requestData, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error: any) {\r\n    console.error('PUT request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * DELETE request\r\n */\r\nexport const del = async <T = any>(\r\n  endpoint: string,\r\n  config?: AxiosRequestConfig\r\n): Promise<ApiResponse<T>> => {\r\n  try {\r\n    const response: AxiosResponse = await apiClient.delete(endpoint, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error: any) {\r\n    console.error('DELETE request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * File upload with multipart/form-data\r\n */\r\nexport const uploadFile = async <T = any>(\r\n  endpoint: string,\r\n  formData: FormData,\r\n  config?: AxiosRequestConfig\r\n): Promise<ApiResponse<T>> => {\r\n  try {\r\n    const response: AxiosResponse = await apiClient.post(endpoint, formData, {\r\n      ...config,\r\n      headers: {\r\n        'Content-Type': 'multipart/form-data',\r\n        ...config?.headers\r\n      }\r\n    });\r\n\r\n    return {\r\n      data: response.data,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: response.data.message\r\n    };\r\n  } catch (error: any) {\r\n    console.error('File upload error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Upload failed'\r\n    };\r\n  }\r\n};\r\n\r\n// Export the axios instance for direct use (backward compatibility)\r\nexport default apiClient;\r\n\r\n// Export all methods as named exports\r\nexport const apiService = {\r\n  get,\r\n  post,\r\n  put,\r\n  delete: del,\r\n  uploadFile,\r\n  encryptData,\r\n  decryptData\r\n};\r\n"
        }
    ]
}