{
    "sourceFile": "Ninico/util/apiService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752833066860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752864792890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,312 @@\n+/**\r\n+ * Encrypted API Service\r\n+ * Provides secure API communication with optional encryption/decryption\r\n+ */\r\n+\r\n+import axios from 'axios';\r\n+import CryptoJS from 'crypto-js';\r\n+import { API_BASE_URL } from './apiEndpoints.js';\r\n+\r\n+// Encryption configuration\r\n+const ENCRYPTION_KEY = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || 'default-32-character-secret-key';\r\n+const ENCRYPTION_IV = process.env.NEXT_PUBLIC_ENCRYPTION_IV || 'default-16-chars';\r\n+\r\n+// Create axios instance with default configuration\r\n+const apiClient = axios.create({\r\n+  baseURL: API_BASE_URL,\r\n+  timeout: 10000,\r\n+  headers: {\r\n+    'Content-Type': 'application/json',\r\n+  },\r\n+});\r\n+\r\n+// Request interceptor to add auth token\r\n+apiClient.interceptors.request.use(\r\n+  (config) => {\r\n+    // Add auth token if available\r\n+    if (typeof window !== 'undefined') {\r\n+      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n+      if (token) {\r\n+        config.headers.Authorization = `Bearer ${token}`;\r\n+      }\r\n+    }\r\n+    return config;\r\n+  },\r\n+  (error) => {\r\n+    return Promise.reject(error);\r\n+  }\r\n+);\r\n+\r\n+// Response interceptor for error handling\r\n+apiClient.interceptors.response.use(\r\n+  (response) => response,\r\n+  (error) => {\r\n+    // Handle common errors\r\n+    if (error.response?.status === 401) {\r\n+      // Clear invalid tokens\r\n+      if (typeof window !== 'undefined') {\r\n+        localStorage.removeItem('authToken');\r\n+        sessionStorage.removeItem('authToken');\r\n+      }\r\n+    }\r\n+    return Promise.reject(error);\r\n+  }\r\n+);\r\n+\r\n+/**\r\n+ * Encrypt data using AES encryption\r\n+ */\r\n+export const encryptData = (data) => {\r\n+  try {\r\n+    const jsonString = JSON.stringify(data);\r\n+    const encrypted = CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY, {\r\n+      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n+      mode: CryptoJS.mode.CBC,\r\n+      padding: CryptoJS.pad.Pkcs7\r\n+    });\r\n+    return encrypted.toString();\r\n+  } catch (error) {\r\n+    console.error('Encryption error:', error);\r\n+    throw new Error('Failed to encrypt data');\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * Decrypt data using AES decryption\r\n+ */\r\n+export const decryptData = (encryptedData) => {\r\n+  try {\r\n+    const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY, {\r\n+      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n+      mode: CryptoJS.mode.CBC,\r\n+      padding: CryptoJS.pad.Pkcs7\r\n+    });\r\n+    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\r\n+    return JSON.parse(decryptedString);\r\n+  } catch (error) {\r\n+    console.error('Decryption error:', error);\r\n+    throw new Error('Failed to decrypt data');\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * POST request with optional encryption\r\n+ */\r\n+export const post = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n+  try {\r\n+    let requestData = payload;\r\n+    \r\n+    // Encrypt payload if requested\r\n+    if (encrypt && payload) {\r\n+      requestData = {\r\n+        encryptedData: encryptData(payload)\r\n+      };\r\n+    }\r\n+\r\n+    const response = await apiClient.post(endpoint, requestData, config);\r\n+    \r\n+    let responseData = response.data;\r\n+    \r\n+    // Decrypt response body if it exists and contains encrypted data\r\n+    if (responseData.body && typeof responseData.body === 'string') {\r\n+      try {\r\n+        responseData.body = decryptData(responseData.body);\r\n+      } catch (error) {\r\n+        // If decryption fails, keep original data\r\n+        console.warn('Failed to decrypt response body, using raw data');\r\n+      }\r\n+    }\r\n+\r\n+    return {\r\n+      data: responseData,\r\n+      success: response.status >= 200 && response.status < 300,\r\n+      status: response.status,\r\n+      message: responseData.message\r\n+    };\r\n+  } catch (error) {\r\n+    console.error('POST request error:', error);\r\n+    throw {\r\n+      data: null,\r\n+      success: false,\r\n+      status: error.response?.status || 500,\r\n+      message: error.response?.data?.message || error.message || 'Request failed'\r\n+    };\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * GET request with optional decryption\r\n+ */\r\n+export const get = async (endpoint, params, decrypt = false, config = {}) => {\r\n+  try {\r\n+    const response = await apiClient.get(endpoint, {\r\n+      ...config,\r\n+      params\r\n+    });\r\n+    \r\n+    let responseData = response.data;\r\n+    \r\n+    // Decrypt response body if requested and it exists\r\n+    if (decrypt && responseData.body && typeof responseData.body === 'string') {\r\n+      try {\r\n+        responseData.body = decryptData(responseData.body);\r\n+      } catch (error) {\r\n+        // If decryption fails, keep original data\r\n+        console.warn('Failed to decrypt response body, using raw data');\r\n+      }\r\n+    }\r\n+\r\n+    return {\r\n+      data: responseData,\r\n+      success: response.status >= 200 && response.status < 300,\r\n+      status: response.status,\r\n+      message: responseData.message\r\n+    };\r\n+  } catch (error) {\r\n+    console.error('GET request error:', error);\r\n+    throw {\r\n+      data: null,\r\n+      success: false,\r\n+      status: error.response?.status || 500,\r\n+      message: error.response?.data?.message || error.message || 'Request failed'\r\n+    };\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * PUT request with optional encryption\r\n+ */\r\n+export const put = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n+  try {\r\n+    let requestData = payload;\r\n+    \r\n+    // Encrypt payload if requested\r\n+    if (encrypt && payload) {\r\n+      requestData = {\r\n+        encryptedData: encryptData(payload)\r\n+      };\r\n+    }\r\n+\r\n+    const response = await apiClient.put(endpoint, requestData, config);\r\n+    \r\n+    let responseData = response.data;\r\n+    \r\n+    // Decrypt response body if it exists and contains encrypted data\r\n+    if (responseData.body && typeof responseData.body === 'string') {\r\n+      try {\r\n+        responseData.body = decryptData(responseData.body);\r\n+      } catch (error) {\r\n+        console.warn('Failed to decrypt response body, using raw data');\r\n+      }\r\n+    }\r\n+\r\n+    return {\r\n+      data: responseData,\r\n+      success: response.status >= 200 && response.status < 300,\r\n+      status: response.status,\r\n+      message: responseData.message\r\n+    };\r\n+  } catch (error) {\r\n+    console.error('PUT request error:', error);\r\n+    throw {\r\n+      data: null,\r\n+      success: false,\r\n+      status: error.response?.status || 500,\r\n+      message: error.response?.data?.message || error.message || 'Request failed'\r\n+    };\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * DELETE request\r\n+ */\r\n+export const del = async (endpoint, config = {}) => {\r\n+  try {\r\n+    const response = await apiClient.delete(endpoint, config);\r\n+    \r\n+    let responseData = response.data;\r\n+    \r\n+    // Decrypt response body if it exists and contains encrypted data\r\n+    if (responseData.body && typeof responseData.body === 'string') {\r\n+      try {\r\n+        responseData.body = decryptData(responseData.body);\r\n+      } catch (error) {\r\n+        console.warn('Failed to decrypt response body, using raw data');\r\n+      }\r\n+    }\r\n+\r\n+    return {\r\n+      data: responseData,\r\n+      success: response.status >= 200 && response.status < 300,\r\n+      status: response.status,\r\n+      message: responseData.message\r\n+    };\r\n+  } catch (error) {\r\n+    console.error('DELETE request error:', error);\r\n+    throw {\r\n+      data: null,\r\n+      success: false,\r\n+      status: error.response?.status || 500,\r\n+      message: error.response?.data?.message || error.message || 'Request failed'\r\n+    };\r\n+  }\r\n+};\r\n+\r\n+/**\r\n+ * File upload with multipart/form-data\r\n+ */\r\n+export const uploadFile = async (endpoint, formData, method = 'POST', config = {}) => {\r\n+  try {\r\n+    let response;\r\n+    const requestConfig = {\r\n+      ...config,\r\n+      headers: {\r\n+        'Content-Type': 'multipart/form-data',\r\n+        ...config?.headers\r\n+      }\r\n+    };\r\n+\r\n+    // Use the appropriate HTTP method\r\n+    switch (method.toUpperCase()) {\r\n+      case 'PUT':\r\n+        response = await apiClient.put(endpoint, formData, requestConfig);\r\n+        break;\r\n+      case 'PATCH':\r\n+        response = await apiClient.patch(endpoint, formData, requestConfig);\r\n+        break;\r\n+      case 'POST':\r\n+      default:\r\n+        response = await apiClient.post(endpoint, formData, requestConfig);\r\n+        break;\r\n+    }\r\n+\r\n+    return {\r\n+      data: response.data,\r\n+      success: response.status >= 200 && response.status < 300,\r\n+      status: response.status,\r\n+      message: response.data.message\r\n+    };\r\n+  } catch (error) {\r\n+    console.error('File upload error:', error);\r\n+    throw {\r\n+      data: null,\r\n+      success: false,\r\n+      status: error.response?.status || 500,\r\n+      message: error.response?.data?.message || error.message || 'Upload failed'\r\n+    };\r\n+  }\r\n+};\r\n+\r\n+// Export the axios instance for direct use (backward compatibility)\r\n+export default apiClient;\r\n+\r\n+// Export all methods as named exports\r\n+export const apiService = {\r\n+  get,\r\n+  post,\r\n+  put,\r\n+  delete: del,\r\n+  uploadFile,\r\n+  encryptData,\r\n+  decryptData\r\n+};\r\n"
                },
                {
                    "date": 1753635797556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,40 +53,66 @@\n   }\r\n );\r\n \r\n /**\r\n- * Encrypt data using AES encryption\r\n+ * Encrypt data using AES encryption (matches backend implementation)\r\n  */\r\n export const encryptData = (data) => {\r\n   try {\r\n+    console.log('🔒 [Frontend] Starting encryption...');\r\n+    console.log('📝 [Frontend] Input data:', data);\r\n+    console.log('📝 [Frontend] Data type:', typeof data);\r\n+    \r\n+    const key = ENCRYPTION_KEY;\r\n+    console.log('🔑 [Frontend] Using key (first 8 chars):', key.substring(0, 8) + '...');\r\n+    \r\n     const jsonString = JSON.stringify(data);\r\n-    const encrypted = CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY, {\r\n-      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n-      mode: CryptoJS.mode.CBC,\r\n-      padding: CryptoJS.pad.Pkcs7\r\n-    });\r\n-    return encrypted.toString();\r\n+    console.log('📝 [Frontend] JSON string:', jsonString);\r\n+    console.log('📝 [Frontend] JSON string length:', jsonString.length);\r\n+    \r\n+    // Use the exact same method as backend (without IV)\r\n+    const encrypted = CryptoJS.AES.encrypt(jsonString, key).toString();\r\n+    console.log('🔒 [Frontend] Encrypted result:', encrypted);\r\n+    console.log('🔒 [Frontend] Encrypted length:', encrypted.length);\r\n+    \r\n+    return encrypted;\r\n   } catch (error) {\r\n-    console.error('Encryption error:', error);\r\n+    console.error('❌ [Frontend] Encryption error:', error);\r\n     throw new Error('Failed to encrypt data');\r\n   }\r\n };\r\n \r\n /**\r\n- * Decrypt data using AES decryption\r\n+ * Decrypt data using AES decryption (matches backend implementation)\r\n  */\r\n export const decryptData = (encryptedData) => {\r\n   try {\r\n-    const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY, {\r\n-      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n-      mode: CryptoJS.mode.CBC,\r\n-      padding: CryptoJS.pad.Pkcs7\r\n-    });\r\n-    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\r\n-    return JSON.parse(decryptedString);\r\n+    console.log('🔓 [Frontend] Starting decryption...');\r\n+    console.log('📝 [Frontend] Input cipher:', encryptedData);\r\n+    console.log('📝 [Frontend] Cipher length:', encryptedData?.length || 0);\r\n+    \r\n+    // Use the same key as backend\r\n+    const key = ENCRYPTION_KEY;\r\n+    console.log('🔑 [Frontend] Using key (first 8 chars):', key.substring(0, 8) + '...');\r\n+    \r\n+    // Use the exact same method as backend (without IV)\r\n+    const decryptedBytes = CryptoJS.AES.decrypt(encryptedData, key);\r\n+    const decryptedString = decryptedBytes.toString(CryptoJS.enc.Utf8);\r\n+    \r\n+    console.log('🔓 [Frontend] Decrypted string:', decryptedString);\r\n+    console.log('🔓 [Frontend] Decrypted string length:', decryptedString.length);\r\n+    \r\n+    if (!decryptedString) {\r\n+      console.error('❌ [Frontend] Failed to decrypt data - empty result');\r\n+      throw new Error('Failed to decrypt data - invalid cipher or key');\r\n+    }\r\n+    \r\n+    const parsed = JSON.parse(decryptedString);\r\n+    console.log('✅ [Frontend] Successfully parsed JSON:', parsed);\r\n+    return parsed;\r\n   } catch (error) {\r\n-    console.error('Decryption error:', error);\r\n-    throw new Error('Failed to decrypt data');\r\n+    console.error('❌ [Frontend] Decryption error:', error);\r\n+    throw new Error('Failed to decrypt data: ' + error.message);\r\n   }\r\n };\r\n \r\n /**\r\n@@ -309,301 +335,4 @@\n   uploadFile,\r\n   encryptData,\r\n   decryptData\r\n };\r\n-/**\r\n- * Encrypted API Service\r\n- * Provides secure API communication with optional encryption/decryption\r\n- */\r\n-\r\n-import axios from 'axios';\r\n-import CryptoJS from 'crypto-js';\r\n-import { API_BASE_URL } from './apiEndpoints.js';\r\n-\r\n-// Encryption configuration\r\n-const ENCRYPTION_KEY = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || 'default-32-character-secret-key';\r\n-const ENCRYPTION_IV = process.env.NEXT_PUBLIC_ENCRYPTION_IV || 'default-16-chars';\r\n-\r\n-// Create axios instance with default configuration\r\n-const apiClient = axios.create({\r\n-  baseURL: API_BASE_URL,\r\n-  timeout: 10000,\r\n-  headers: {\r\n-    'Content-Type': 'application/json',\r\n-  },\r\n-});\r\n-\r\n-// Request interceptor to add auth token\r\n-apiClient.interceptors.request.use(\r\n-  (config) => {\r\n-    // Add auth token if available\r\n-    if (typeof window !== 'undefined') {\r\n-      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n-      if (token) {\r\n-        config.headers.Authorization = `Bearer ${token}`;\r\n-      }\r\n-    }\r\n-    return config;\r\n-  },\r\n-  (error) => {\r\n-    return Promise.reject(error);\r\n-  }\r\n-);\r\n-\r\n-// Response interceptor for error handling\r\n-apiClient.interceptors.response.use(\r\n-  (response) => response,\r\n-  (error) => {\r\n-    // Handle common errors\r\n-    if (error.response?.status === 401) {\r\n-      // Clear invalid tokens\r\n-      if (typeof window !== 'undefined') {\r\n-        localStorage.removeItem('authToken');\r\n-        sessionStorage.removeItem('authToken');\r\n-      }\r\n-    }\r\n-    return Promise.reject(error);\r\n-  }\r\n-);\r\n-\r\n-/**\r\n- * Encrypt data using AES encryption\r\n- */\r\n-export const encryptData = (data) => {\r\n-  try {\r\n-    const jsonString = JSON.stringify(data);\r\n-    const encrypted = CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY, {\r\n-      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n-      mode: CryptoJS.mode.CBC,\r\n-      padding: CryptoJS.pad.Pkcs7\r\n-    });\r\n-    return encrypted.toString();\r\n-  } catch (error) {\r\n-    console.error('Encryption error:', error);\r\n-    throw new Error('Failed to encrypt data');\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * Decrypt data using AES decryption\r\n- */\r\n-export const decryptData = (encryptedData) => {\r\n-  try {\r\n-    const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY, {\r\n-      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n-      mode: CryptoJS.mode.CBC,\r\n-      padding: CryptoJS.pad.Pkcs7\r\n-    });\r\n-    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\r\n-    return JSON.parse(decryptedString);\r\n-  } catch (error) {\r\n-    console.error('Decryption error:', error);\r\n-    throw new Error('Failed to decrypt data');\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * POST request with optional encryption\r\n- */\r\n-export const post = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n-  try {\r\n-    let requestData = payload;\r\n-    \r\n-    // Encrypt payload if requested\r\n-    if (encrypt && payload) {\r\n-      requestData = {\r\n-        encryptedData: encryptData(payload)\r\n-      };\r\n-    }\r\n-\r\n-    const response = await apiClient.post(endpoint, requestData, config);\r\n-    \r\n-    let responseData = response.data;\r\n-    \r\n-    // Decrypt response body if it exists and contains encrypted data\r\n-    if (responseData.body && typeof responseData.body === 'string') {\r\n-      try {\r\n-        responseData.body = decryptData(responseData.body);\r\n-      } catch (error) {\r\n-        // If decryption fails, keep original data\r\n-        console.warn('Failed to decrypt response body, using raw data');\r\n-      }\r\n-    }\r\n-\r\n-    return {\r\n-      data: responseData,\r\n-      success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: responseData.message\r\n-    };\r\n-  } catch (error) {\r\n-    console.error('POST request error:', error);\r\n-    throw {\r\n-      data: null,\r\n-      success: false,\r\n-      status: error.response?.status || 500,\r\n-      message: error.response?.data?.message || error.message || 'Request failed'\r\n-    };\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * GET request with optional decryption\r\n- */\r\n-export const get = async (endpoint, params, decrypt = false, config = {}) => {\r\n-  try {\r\n-    const response = await apiClient.get(endpoint, {\r\n-      ...config,\r\n-      params\r\n-    });\r\n-    \r\n-    let responseData = response.data;\r\n-    \r\n-    // Decrypt response body if requested and it exists\r\n-    if (decrypt && responseData.body && typeof responseData.body === 'string') {\r\n-      try {\r\n-        responseData.body = decryptData(responseData.body);\r\n-      } catch (error) {\r\n-        // If decryption fails, keep original data\r\n-        console.warn('Failed to decrypt response body, using raw data');\r\n-      }\r\n-    }\r\n-\r\n-    return {\r\n-      data: responseData,\r\n-      success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: responseData.message\r\n-    };\r\n-  } catch (error) {\r\n-    console.error('GET request error:', error);\r\n-    throw {\r\n-      data: null,\r\n-      success: false,\r\n-      status: error.response?.status || 500,\r\n-      message: error.response?.data?.message || error.message || 'Request failed'\r\n-    };\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * PUT request with optional encryption\r\n- */\r\n-export const put = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n-  try {\r\n-    let requestData = payload;\r\n-    \r\n-    // Encrypt payload if requested\r\n-    if (encrypt && payload) {\r\n-      requestData = {\r\n-        encryptedData: encryptData(payload)\r\n-      };\r\n-    }\r\n-\r\n-    const response = await apiClient.put(endpoint, requestData, config);\r\n-    \r\n-    let responseData = response.data;\r\n-    \r\n-    // Decrypt response body if it exists and contains encrypted data\r\n-    if (responseData.body && typeof responseData.body === 'string') {\r\n-      try {\r\n-        responseData.body = decryptData(responseData.body);\r\n-      } catch (error) {\r\n-        console.warn('Failed to decrypt response body, using raw data');\r\n-      }\r\n-    }\r\n-\r\n-    return {\r\n-      data: responseData,\r\n-      success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: responseData.message\r\n-    };\r\n-  } catch (error) {\r\n-    console.error('PUT request error:', error);\r\n-    throw {\r\n-      data: null,\r\n-      success: false,\r\n-      status: error.response?.status || 500,\r\n-      message: error.response?.data?.message || error.message || 'Request failed'\r\n-    };\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * DELETE request\r\n- */\r\n-export const del = async (endpoint, config = {}) => {\r\n-  try {\r\n-    const response = await apiClient.delete(endpoint, config);\r\n-    \r\n-    let responseData = response.data;\r\n-    \r\n-    // Decrypt response body if it exists and contains encrypted data\r\n-    if (responseData.body && typeof responseData.body === 'string') {\r\n-      try {\r\n-        responseData.body = decryptData(responseData.body);\r\n-      } catch (error) {\r\n-        console.warn('Failed to decrypt response body, using raw data');\r\n-      }\r\n-    }\r\n-\r\n-    return {\r\n-      data: responseData,\r\n-      success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: responseData.message\r\n-    };\r\n-  } catch (error) {\r\n-    console.error('DELETE request error:', error);\r\n-    throw {\r\n-      data: null,\r\n-      success: false,\r\n-      status: error.response?.status || 500,\r\n-      message: error.response?.data?.message || error.message || 'Request failed'\r\n-    };\r\n-  }\r\n-};\r\n-\r\n-/**\r\n- * File upload with multipart/form-data\r\n- */\r\n-export const uploadFile = async (endpoint, formData, config = {}) => {\r\n-  try {\r\n-    const response = await apiClient.post(endpoint, formData, {\r\n-      ...config,\r\n-      headers: {\r\n-        'Content-Type': 'multipart/form-data',\r\n-        ...config?.headers\r\n-      }\r\n-    });\r\n-\r\n-    return {\r\n-      data: response.data,\r\n-      success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: response.data.message\r\n-    };\r\n-  } catch (error) {\r\n-    console.error('File upload error:', error);\r\n-    throw {\r\n-      data: null,\r\n-      success: false,\r\n-      status: error.response?.status || 500,\r\n-      message: error.response?.data?.message || error.message || 'Upload failed'\r\n-    };\r\n-  }\r\n-};\r\n-\r\n-// Export the axios instance for direct use (backward compatibility)\r\n-export default apiClient;\r\n-\r\n-// Export all methods as named exports\r\n-export const apiService = {\r\n-  get,\r\n-  post,\r\n-  put,\r\n-  delete: del,\r\n-  uploadFile,\r\n-  encryptData,\r\n-  decryptData\r\n-};\r\n"
                },
                {
                    "date": 1753949861898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,23 @@\n apiClient.interceptors.request.use(\r\n   (config) => {\r\n     // Add auth token if available\r\n     if (typeof window !== 'undefined') {\r\n-      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n-      if (token) {\r\n-        config.headers.Authorization = `Bearer ${token}`;\r\n+      // Check for admin token first if the request is to an admin endpoint\r\n+      const isAdminRequest = config.url.includes('/admin') || config.headers['x-admin-request'] === 'true';\r\n+      if (isAdminRequest) {\r\n+        const adminToken = localStorage.getItem('adminToken');\r\n+        if (adminToken) {\r\n+          config.headers.Authorization = `Bearer ${adminToken}`;\r\n+        } else {\r\n+          console.warn('🚫 Admin token not found for admin request');\r\n+        }\r\n+      } else {\r\n+        // For regular user requests\r\n+        const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n+        if (token) {\r\n+          config.headers.Authorization = `Bearer ${token}`;\r\n+        }\r\n       }\r\n     }\r\n     return config;\r\n   },\r\n"
                },
                {
                    "date": 1753950970907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,18 +48,45 @@\n     return Promise.reject(error);\r\n   }\r\n );\r\n \r\n-// Response interceptor for error handling\r\n+// Response interceptor for error handling and decryption\r\n apiClient.interceptors.response.use(\r\n-  (response) => response,\r\n+  (response) => {\r\n+    // Check if response is encrypted\r\n+    if (response.data && typeof response.data === 'string' && response.data.startsWith('U2FsdGVk')) {\r\n+      try {\r\n+        console.log('🔐 Encrypted response detected, attempting decryption');\r\n+        // Decrypt the response\r\n+        const decryptedText = CryptoJS.AES.decrypt(\r\n+          response.data,\r\n+          ENCRYPTION_KEY\r\n+        ).toString(CryptoJS.enc.Utf8);\r\n+        \r\n+        const decryptedData = JSON.parse(decryptedText);\r\n+        console.log('🔓 Successfully decrypted response:', decryptedData);\r\n+        \r\n+        // Return decrypted data with encryption flag\r\n+        return {\r\n+          ...response,\r\n+          data: decryptedData,\r\n+          encryptedData: true\r\n+        };\r\n+      } catch (decryptError) {\r\n+        console.error('❌ Failed to decrypt response:', decryptError);\r\n+        return response;\r\n+      }\r\n+    }\r\n+    return response;\r\n+  },\r\n   (error) => {\r\n     // Handle common errors\r\n     if (error.response?.status === 401) {\r\n       // Clear invalid tokens\r\n       if (typeof window !== 'undefined') {\r\n         localStorage.removeItem('authToken');\r\n         sessionStorage.removeItem('authToken');\r\n+        localStorage.removeItem('adminToken');\r\n       }\r\n     }\r\n     return Promise.reject(error);\r\n   }\r\n@@ -140,27 +167,24 @@\n         encryptedData: encryptData(payload)\r\n       };\r\n     }\r\n \r\n+    console.log('🚀 Sending request to:', endpoint);\r\n+    console.log('📦 Request payload:', requestData);\r\n+\r\n     const response = await apiClient.post(endpoint, requestData, config);\r\n     \r\n-    let responseData = response.data;\r\n+    console.log('✅ Response received:', response.data);\r\n+\r\n+    // Handle both encrypted and unencrypted responses\r\n+    const responseData = response.data;\r\n     \r\n-    // Decrypt response body if it exists and contains encrypted data\r\n-    if (responseData.body && typeof responseData.body === 'string') {\r\n-      try {\r\n-        responseData.body = decryptData(responseData.body);\r\n-      } catch (error) {\r\n-        // If decryption fails, keep original data\r\n-        console.warn('Failed to decrypt response body, using raw data');\r\n-      }\r\n-    }\r\n-\r\n+    // If it was encrypted, response.encryptedData will be true\r\n+    // and response.data will already be decrypted by the interceptor\r\n     return {\r\n-      data: responseData,\r\n+      ...responseData,\r\n       success: response.status >= 200 && response.status < 300,\r\n-      status: response.status,\r\n-      message: responseData.message\r\n+      status: response.status\r\n     };\r\n   } catch (error) {\r\n     console.error('POST request error:', error);\r\n     throw {\r\n"
                }
            ],
            "date": 1752833066860,
            "name": "Commit-0",
            "content": "/**\r\n * Encrypted API Service\r\n * Provides secure API communication with optional encryption/decryption\r\n */\r\n\r\nimport axios from 'axios';\r\nimport CryptoJS from 'crypto-js';\r\nimport { API_BASE_URL } from './apiEndpoints.js';\r\n\r\n// Encryption configuration\r\nconst ENCRYPTION_KEY = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || 'default-32-character-secret-key';\r\nconst ENCRYPTION_IV = process.env.NEXT_PUBLIC_ENCRYPTION_IV || 'default-16-chars';\r\n\r\n// Create axios instance with default configuration\r\nconst apiClient = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 10000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n// Request interceptor to add auth token\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    // Add auth token if available\r\n    if (typeof window !== 'undefined') {\r\n      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n      if (token) {\r\n        config.headers.Authorization = `Bearer ${token}`;\r\n      }\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor for error handling\r\napiClient.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    // Handle common errors\r\n    if (error.response?.status === 401) {\r\n      // Clear invalid tokens\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.removeItem('authToken');\r\n        sessionStorage.removeItem('authToken');\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n/**\r\n * Encrypt data using AES encryption\r\n */\r\nexport const encryptData = (data) => {\r\n  try {\r\n    const jsonString = JSON.stringify(data);\r\n    const encrypted = CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY, {\r\n      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    return encrypted.toString();\r\n  } catch (error) {\r\n    console.error('Encryption error:', error);\r\n    throw new Error('Failed to encrypt data');\r\n  }\r\n};\r\n\r\n/**\r\n * Decrypt data using AES decryption\r\n */\r\nexport const decryptData = (encryptedData) => {\r\n  try {\r\n    const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY, {\r\n      iv: CryptoJS.enc.Utf8.parse(ENCRYPTION_IV),\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\r\n    return JSON.parse(decryptedString);\r\n  } catch (error) {\r\n    console.error('Decryption error:', error);\r\n    throw new Error('Failed to decrypt data');\r\n  }\r\n};\r\n\r\n/**\r\n * POST request with optional encryption\r\n */\r\nexport const post = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n  try {\r\n    let requestData = payload;\r\n    \r\n    // Encrypt payload if requested\r\n    if (encrypt && payload) {\r\n      requestData = {\r\n        encryptedData: encryptData(payload)\r\n      };\r\n    }\r\n\r\n    const response = await apiClient.post(endpoint, requestData, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        // If decryption fails, keep original data\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error) {\r\n    console.error('POST request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * GET request with optional decryption\r\n */\r\nexport const get = async (endpoint, params, decrypt = false, config = {}) => {\r\n  try {\r\n    const response = await apiClient.get(endpoint, {\r\n      ...config,\r\n      params\r\n    });\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if requested and it exists\r\n    if (decrypt && responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        // If decryption fails, keep original data\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error) {\r\n    console.error('GET request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * PUT request with optional encryption\r\n */\r\nexport const put = async (endpoint, payload = {}, encrypt = false, config = {}) => {\r\n  try {\r\n    let requestData = payload;\r\n    \r\n    // Encrypt payload if requested\r\n    if (encrypt && payload) {\r\n      requestData = {\r\n        encryptedData: encryptData(payload)\r\n      };\r\n    }\r\n\r\n    const response = await apiClient.put(endpoint, requestData, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error) {\r\n    console.error('PUT request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * DELETE request\r\n */\r\nexport const del = async (endpoint, config = {}) => {\r\n  try {\r\n    const response = await apiClient.delete(endpoint, config);\r\n    \r\n    let responseData = response.data;\r\n    \r\n    // Decrypt response body if it exists and contains encrypted data\r\n    if (responseData.body && typeof responseData.body === 'string') {\r\n      try {\r\n        responseData.body = decryptData(responseData.body);\r\n      } catch (error) {\r\n        console.warn('Failed to decrypt response body, using raw data');\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: responseData,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: responseData.message\r\n    };\r\n  } catch (error) {\r\n    console.error('DELETE request error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Request failed'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * File upload with multipart/form-data\r\n */\r\nexport const uploadFile = async (endpoint, formData, config = {}) => {\r\n  try {\r\n    const response = await apiClient.post(endpoint, formData, {\r\n      ...config,\r\n      headers: {\r\n        'Content-Type': 'multipart/form-data',\r\n        ...config?.headers\r\n      }\r\n    });\r\n\r\n    return {\r\n      data: response.data,\r\n      success: response.status >= 200 && response.status < 300,\r\n      status: response.status,\r\n      message: response.data.message\r\n    };\r\n  } catch (error) {\r\n    console.error('File upload error:', error);\r\n    throw {\r\n      data: null,\r\n      success: false,\r\n      status: error.response?.status || 500,\r\n      message: error.response?.data?.message || error.message || 'Upload failed'\r\n    };\r\n  }\r\n};\r\n\r\n// Export the axios instance for direct use (backward compatibility)\r\nexport default apiClient;\r\n\r\n// Export all methods as named exports\r\nexport const apiService = {\r\n  get,\r\n  post,\r\n  put,\r\n  delete: del,\r\n  uploadFile,\r\n  encryptData,\r\n  decryptData\r\n};\r\n"
        }
    ]
}