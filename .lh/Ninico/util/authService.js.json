{
    "sourceFile": "Ninico/util/authService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1753614088169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753634367351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,243 @@\n+/**\r\n+ * Authentication Service\r\n+ * Provides authentication-specific API methods using the generic API service\r\n+ */\r\n+\r\n+import { get, post } from './apiService.js';\r\n+import { AUTH, OTP } from './apiEndpoints.js';\r\n+\r\n+/**\r\n+ * Authentication Service Class\r\n+ */\r\n+class AuthService {\r\n+  \r\n+  /**\r\n+   * Check if user exists by phone number\r\n+   * @param {string} phone - Phone number to check\r\n+   * @returns {Promise<Object>} - User existence result\r\n+   */\r\n+  async checkUserByPhone(phone) {\r\n+    try {\r\n+      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Check user by phone error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Check if user exists by email (for corporate flow)\r\n+   * @param {string} email - Email to check\r\n+   * @returns {Promise<Object>} - User existence result with userType\r\n+   */\r\n+  async checkUserByEmail(email) {\r\n+    try {\r\n+      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Check user by email error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * User login\r\n+   * @param {Object} credentials - Login credentials\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Login result\r\n+   */\r\n+  async login(credentials, encrypt = true) {\r\n+    try {\r\n+      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n+      \r\n+      // Store auth token if login successful\r\n+      if (response.success && response.data?.data?.token) {\r\n+        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n+        storage.setItem('authToken', response.data.data.token);\r\n+        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n+      }\r\n+      \r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Login error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * User signup/registration\r\n+   * @param {Object} userData - User registration data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Registration result\r\n+   */\r\n+  async signup(userData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(AUTH.SIGNUP, userData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      if (response.data?.success) {\r\n+        return {\r\n+          success: true,\r\n+          message: response.data.message,\r\n+          data: response.data\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: response.data?.message || 'Registration failed'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Signup error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Registration failed'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Password reset\r\n+   * @param {Object} resetData - Password reset data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - Reset result\r\n+   */\r\n+  async resetPassword(resetData, encrypt = true) {\r\n+    try {\r\n+      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n+      return response;\r\n+    } catch (error) {\r\n+      console.error('Reset password error:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Send OTP\r\n+   * @param {Object} otpData - OTP request data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - OTP send result\r\n+   */\r\n+  async sendOTP(otpData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(OTP.SEND, otpData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      return {\r\n+        success: true,\r\n+        message: response.data?.message || 'OTP sent successfully'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Send OTP error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Failed to send OTP'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Verify OTP\r\n+   * @param {Object} verifyData - OTP verification data\r\n+   * @param {boolean} encrypt - Whether to encrypt the request\r\n+   * @returns {Promise<Object>} - OTP verification result\r\n+   */\r\n+  async verifyOTP(verifyData, encrypt = true) {\r\n+    try {\r\n+      const controller = new AbortController();\r\n+      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\r\n+      \r\n+      const response = await post(OTP.VERIFY, verifyData, encrypt, { signal: controller.signal });\r\n+      clearTimeout(timeoutId);\r\n+      \r\n+      return {\r\n+        success: true,\r\n+        message: response.data?.message || 'OTP verified successfully'\r\n+      };\r\n+    } catch (error) {\r\n+      console.error('Verify OTP error:', error);\r\n+      \r\n+      if (error.name === 'AbortError') {\r\n+        return {\r\n+          success: false,\r\n+          message: 'Request timeout. Please check your connection and try again.'\r\n+        };\r\n+      }\r\n+      \r\n+      return {\r\n+        success: false,\r\n+        message: error.response?.data?.message || error.message || 'Invalid OTP'\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Logout user\r\n+   */\r\n+  logout() {\r\n+    // Clear all auth data from storage\r\n+    localStorage.removeItem('authToken');\r\n+    localStorage.removeItem('user');\r\n+    sessionStorage.removeItem('authToken');\r\n+    sessionStorage.removeItem('user');\r\n+  }\r\n+\r\n+  /**\r\n+   * Get current user from storage\r\n+   * @returns {Object|null} - Current user data\r\n+   */\r\n+  getCurrentUser() {\r\n+    try {\r\n+      const userFromLocal = localStorage.getItem('user');\r\n+      const userFromSession = sessionStorage.getItem('user');\r\n+      const userData = userFromLocal || userFromSession;\r\n+      \r\n+      return userData ? JSON.parse(userData) : null;\r\n+    } catch (error) {\r\n+      console.error('Error getting current user:', error);\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Get current auth token\r\n+   * @returns {string|null} - Current auth token\r\n+   */\r\n+  getAuthToken() {\r\n+    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n+  }\r\n+\r\n+  /**\r\n+   * Check if user is authenticated\r\n+   * @returns {boolean} - Authentication status\r\n+   */\r\n+  isAuthenticated() {\r\n+    return !!this.getAuthToken();\r\n+  }\r\n+}\r\n+\r\n+// Export singleton instance\r\n+export default new AuthService();\r\n"
                },
                {
                    "date": 1753634453805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -240,182 +240,4 @@\n }\r\n \r\n // Export singleton instance\r\n export default new AuthService();\r\n-/**\r\n- * Authentication Service\r\n- * Provides authentication-specific API methods using the generic API service\r\n- */\r\n-\r\n-import { get, post } from './apiService.js';\r\n-import { AUTH, OTP } from './apiEndpoints.js';\r\n-\r\n-/**\r\n- * Authentication Service Class\r\n- */\r\n-class AuthService {\r\n-  \r\n-  /**\r\n-   * Check if user exists by phone number\r\n-   * @param {string} phone - Phone number to check\r\n-   * @returns {Promise<Object>} - User existence result\r\n-   */\r\n-  async checkUserByPhone(phone) {\r\n-    try {\r\n-      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Check user by phone error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Check if user exists by email (for corporate flow)\r\n-   * @param {string} email - Email to check\r\n-   * @returns {Promise<Object>} - User existence result with userType\r\n-   */\r\n-  async checkUserByEmail(email) {\r\n-    try {\r\n-      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Check user by email error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * User login\r\n-   * @param {Object} credentials - Login credentials\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Login result\r\n-   */\r\n-  async login(credentials, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n-      \r\n-      // Store auth token if login successful\r\n-      if (response.success && response.data?.data?.token) {\r\n-        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n-        storage.setItem('authToken', response.data.data.token);\r\n-        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n-      }\r\n-      \r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Login error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * User signup/registration\r\n-   * @param {Object} userData - User registration data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Registration result\r\n-   */\r\n-  async signup(userData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.SIGNUP, userData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Signup error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Password reset\r\n-   * @param {Object} resetData - Password reset data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - Reset result\r\n-   */\r\n-  async resetPassword(resetData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Reset password error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Send OTP\r\n-   * @param {Object} otpData - OTP request data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - OTP send result\r\n-   */\r\n-  async sendOTP(otpData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(OTP.SEND, otpData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Send OTP error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Verify OTP\r\n-   * @param {Object} verifyData - OTP verification data\r\n-   * @param {boolean} encrypt - Whether to encrypt the request\r\n-   * @returns {Promise<Object>} - OTP verification result\r\n-   */\r\n-  async verifyOTP(verifyData, encrypt = true) {\r\n-    try {\r\n-      const response = await post(OTP.VERIFY, verifyData, encrypt);\r\n-      return response;\r\n-    } catch (error) {\r\n-      console.error('Verify OTP error:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Logout user\r\n-   */\r\n-  logout() {\r\n-    // Clear all auth data from storage\r\n-    localStorage.removeItem('authToken');\r\n-    localStorage.removeItem('user');\r\n-    sessionStorage.removeItem('authToken');\r\n-    sessionStorage.removeItem('user');\r\n-  }\r\n-\r\n-  /**\r\n-   * Get current user from storage\r\n-   * @returns {Object|null} - Current user data\r\n-   */\r\n-  getCurrentUser() {\r\n-    try {\r\n-      const userFromLocal = localStorage.getItem('user');\r\n-      const userFromSession = sessionStorage.getItem('user');\r\n-      const userData = userFromLocal || userFromSession;\r\n-      \r\n-      return userData ? JSON.parse(userData) : null;\r\n-    } catch (error) {\r\n-      console.error('Error getting current user:', error);\r\n-      return null;\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Get current auth token\r\n-   * @returns {string|null} - Current auth token\r\n-   */\r\n-  getAuthToken() {\r\n-    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n-  }\r\n-\r\n-  /**\r\n-   * Check if user is authenticated\r\n-   * @returns {boolean} - Authentication status\r\n-   */\r\n-  isAuthenticated() {\r\n-    return !!this.getAuthToken();\r\n-  }\r\n-}\r\n-\r\n-// Export singleton instance\r\n-export default new AuthService();\r\n"
                },
                {
                    "date": 1753635797559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,20 +48,111 @@\n    * @returns {Promise<Object>} - Login result\r\n    */\r\n   async login(credentials, encrypt = true) {\r\n     try {\r\n+      console.log('🔐 [AuthService] Login attempt:', { \r\n+        hasEmail: !!credentials.email, \r\n+        hasPhone: !!credentials.phone, \r\n+        userType: credentials.userType \r\n+      })\r\n+      \r\n       const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n       \r\n-      // Store auth token if login successful\r\n+      console.log('📥 [AuthService] Login response received:', { \r\n+        success: response.success, \r\n+        hasData: !!response.data,\r\n+        hasEncryptedData: !!response.data?.encryptedData\r\n+      })\r\n+\r\n+      // Handle encrypted response\r\n+      if (response.success && response.data?.encryptedData) {\r\n+        console.log('🔓 [AuthService] Decrypting response data...')\r\n+        \r\n+        try {\r\n+          // Import decryptData function\r\n+          const { decryptData } = await import('./apiService.js')\r\n+          \r\n+          // Decrypt the response\r\n+          const decryptedData = decryptData(response.data.encryptedData)\r\n+          console.log('✅ [AuthService] Decryption successful:', {\r\n+            hasUser: !!decryptedData.data?.user,\r\n+            hasToken: !!decryptedData.data?.token\r\n+          })\r\n+          \r\n+          // Store auth data if login successful\r\n+          if (decryptedData.success && decryptedData.data) {\r\n+            const { token, user } = decryptedData.data\r\n+            \r\n+            if (token) {\r\n+              const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n+              storage.setItem('authToken', token);\r\n+              console.log('💾 [AuthService] Token stored successfully')\r\n+            }\r\n+            \r\n+            if (user) {\r\n+              const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n+              storage.setItem('user', JSON.stringify(user));\r\n+              console.log('💾 [AuthService] User data stored:', {\r\n+                name: user.name,\r\n+                email: user.email,\r\n+                userType: user.userType\r\n+              })\r\n+            }\r\n+            \r\n+            // Return in the expected format\r\n+            return {\r\n+              success: true,\r\n+              data: {\r\n+                data: {\r\n+                  token,\r\n+                  user\r\n+                }\r\n+              },\r\n+              message: decryptedData.message || 'Login successful'\r\n+            }\r\n+          }\r\n+          \r\n+          return {\r\n+            success: false,\r\n+            message: decryptedData.message || 'Login failed'\r\n+          }\r\n+          \r\n+        } catch (decryptError) {\r\n+          console.error('❌ [AuthService] Decryption failed:', decryptError)\r\n+          return {\r\n+            success: false,\r\n+            message: 'Failed to process server response'\r\n+          }\r\n+        }\r\n+      }\r\n+      \r\n+      // Handle unencrypted response (fallback)\r\n       if (response.success && response.data?.data?.token) {\r\n         const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n         storage.setItem('authToken', response.data.data.token);\r\n         storage.setItem('user', JSON.stringify(response.data.data.user));\r\n+        console.log('💾 [AuthService] Auth data stored successfully (unencrypted)')\r\n+      } else if (response.success && response.data?.token) {\r\n+        // Handle alternative token structure\r\n+        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n+        storage.setItem('authToken', response.data.token);\r\n+        storage.setItem('user', JSON.stringify(response.data.user));\r\n+        console.log('💾 [AuthService] Auth data stored successfully (alt structure)')\r\n       }\r\n       \r\n       return response;\r\n     } catch (error) {\r\n-      console.error('Login error:', error);\r\n+      console.error('❌ [AuthService] Login error:', error);\r\n+      \r\n+      // Enhanced error handling for corporate login\r\n+      if (error.response?.status === 401) {\r\n+        if (credentials.userType === 'Corporate') {\r\n+          throw new Error('Invalid corporate email or password');\r\n+        } else {\r\n+          throw new Error('Invalid credentials');\r\n+        }\r\n+      }\r\n+      \r\n       throw error;\r\n     }\r\n   }\r\n \r\n"
                }
            ],
            "date": 1753614088169,
            "name": "Commit-0",
            "content": "/**\r\n * Authentication Service\r\n * Provides authentication-specific API methods using the generic API service\r\n */\r\n\r\nimport { get, post } from './apiService.js';\r\nimport { AUTH, OTP } from './apiEndpoints.js';\r\n\r\n/**\r\n * Authentication Service Class\r\n */\r\nclass AuthService {\r\n  \r\n  /**\r\n   * Check if user exists by phone number\r\n   * @param {string} phone - Phone number to check\r\n   * @returns {Promise<Object>} - User existence result\r\n   */\r\n  async checkUserByPhone(phone) {\r\n    try {\r\n      const response = await get(`${AUTH.CHECK_USER}/${phone}`);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check user by phone error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user exists by email (for corporate flow)\r\n   * @param {string} email - Email to check\r\n   * @returns {Promise<Object>} - User existence result with userType\r\n   */\r\n  async checkUserByEmail(email) {\r\n    try {\r\n      const response = await get(`${AUTH.CHECK_USER_EMAIL}/${encodeURIComponent(email)}`);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Check user by email error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * User login\r\n   * @param {Object} credentials - Login credentials\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Login result\r\n   */\r\n  async login(credentials, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.LOGIN, credentials, encrypt);\r\n      \r\n      // Store auth token if login successful\r\n      if (response.success && response.data?.data?.token) {\r\n        const storage = credentials.rememberMe ? localStorage : sessionStorage;\r\n        storage.setItem('authToken', response.data.data.token);\r\n        storage.setItem('user', JSON.stringify(response.data.data.user));\r\n      }\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('Login error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * User signup/registration\r\n   * @param {Object} userData - User registration data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Registration result\r\n   */\r\n  async signup(userData, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.SIGNUP, userData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Signup error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Password reset\r\n   * @param {Object} resetData - Password reset data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - Reset result\r\n   */\r\n  async resetPassword(resetData, encrypt = true) {\r\n    try {\r\n      const response = await post(AUTH.RESET_PASSWORD, resetData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Reset password error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send OTP\r\n   * @param {Object} otpData - OTP request data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - OTP send result\r\n   */\r\n  async sendOTP(otpData, encrypt = true) {\r\n    try {\r\n      const response = await post(OTP.SEND, otpData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Send OTP error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify OTP\r\n   * @param {Object} verifyData - OTP verification data\r\n   * @param {boolean} encrypt - Whether to encrypt the request\r\n   * @returns {Promise<Object>} - OTP verification result\r\n   */\r\n  async verifyOTP(verifyData, encrypt = true) {\r\n    try {\r\n      const response = await post(OTP.VERIFY, verifyData, encrypt);\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Verify OTP error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logout user\r\n   */\r\n  logout() {\r\n    // Clear all auth data from storage\r\n    localStorage.removeItem('authToken');\r\n    localStorage.removeItem('user');\r\n    sessionStorage.removeItem('authToken');\r\n    sessionStorage.removeItem('user');\r\n  }\r\n\r\n  /**\r\n   * Get current user from storage\r\n   * @returns {Object|null} - Current user data\r\n   */\r\n  getCurrentUser() {\r\n    try {\r\n      const userFromLocal = localStorage.getItem('user');\r\n      const userFromSession = sessionStorage.getItem('user');\r\n      const userData = userFromLocal || userFromSession;\r\n      \r\n      return userData ? JSON.parse(userData) : null;\r\n    } catch (error) {\r\n      console.error('Error getting current user:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current auth token\r\n   * @returns {string|null} - Current auth token\r\n   */\r\n  getAuthToken() {\r\n    return localStorage.getItem('authToken') || sessionStorage.getItem('authToken');\r\n  }\r\n\r\n  /**\r\n   * Check if user is authenticated\r\n   * @returns {boolean} - Authentication status\r\n   */\r\n  isAuthenticated() {\r\n    return !!this.getAuthToken();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport default new AuthService();\r\n"
        }
    ]
}