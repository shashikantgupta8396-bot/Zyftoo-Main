Index
=====
1. Introduction
2. What is Auth Centralization?
3. Main Components
4. How a Login Request Flows (with Diagram)
5. How Route Protection Works (with Diagram)
6. Middleware and Role Checks (with Diagram)
7. User Roles and Permissions (with Diagram)
8. Use Case Examples
9. Where to Change What?
10. Summary

---

1. Introduction
---------------
This guide explains how authentication (auth) and admin logic is centralized in your project. It uses simple language, diagrams, and real use cases so you can understand and update the system easily.

2. What is Auth Centralization?
-------------------------------
Auth centralization means all login, registration, and admin logic is handled in one place (not scattered everywhere). This makes the system more secure, easier to update, and less error-prone.

3. Main Components
------------------
- **Frontend**: React/Next.js with AuthContext and ProtectedRoute
- **Backend**: AuthService, AdminService, Middleware (protect, adminOnly, etc.)
- **Database**: User, Admin, and other models

4. How a Login Request Flows
----------------------------
[Insert Diagram: Login Request Flow]
- User enters credentials in the frontend
- AuthContext sends request to backend
- Backend AuthService checks user and password
- If correct, returns a token and user info
- AuthContext stores token and user info

5. How Route Protection Works
-----------------------------
[Insert Diagram: Protected Route Flow]
- When a user visits a protected page, AuthContext checks if they are logged in
- If not, shows login page
- If yes, checks if they have the right role/permission
- If not, shows "Access Denied"
- If yes, shows the page

6. Middleware and Role Checks
-----------------------------
[Insert Diagram: Middleware Chain]
- Every backend route can use middleware like `protect`, `adminOnly`, or `requireRoles`
- `protect` checks if the user is logged in (valid token)
- `adminOnly` checks if the user is an admin
- `requireRoles` checks for any allowed role

7. User Roles and Permissions
-----------------------------
[Insert Diagram: Role/Permission Matrix]
- User: can view and update profile, place orders
- Corporate: can do everything a user can, plus bulk orders
- Admin: can manage users, products, orders, content
- SuperAdmin: can do everything

8. Use Case Examples
--------------------
- **User Registration**: User fills signup form, AuthService creates user, sends verification email
- **Admin Creating User**: Admin uses admin panel, AdminService creates user directly
- **Corporate Bulk Order**: Corporate user logs in, accesses bulk order page
- **Permission-based Feature**: User tries to access admin feature, system checks permission

9. Where to Change What?
------------------------
- **Add new permission**: Update permissions in AuthContext and backend RBAC
- **Create new protected route**: Use ProtectedRoute/AdminRoute in frontend, add middleware in backend
- **Add admin feature**: Use AdminService and AdminRoute
- **Modify auth logic**: Update AuthService methods
- **Change middleware**: Update authMiddleware.js

10. Summary
-----------
Centralized auth makes your app secure, easy to update, and scalable. Every request goes through the same checks, and you always know where to look to change something.

---

[For diagrams, use the provided Mermaid code in the previous answer. You can export them as images and insert them into this document.]
